"use strict";(self.webpackChunkpyrsia=self.webpackChunkpyrsia||[]).push([[1477],{30010:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/2022/11/30/pyrsia-0.2.1-released","metadata":{"permalink":"/blog/2022/11/30/pyrsia-0.2.1-released","source":"@site/blog/2022-11-30-pyrsia-0.2.1-released.md","title":"Release 0.2.1","description":"Announcing a new release","date":"2022-11-30T00:00:00.000Z","formattedDate":"November 30, 2022","tags":[{"label":"pyrsia","permalink":"/blog/tags/pyrsia"},{"label":"cli","permalink":"/blog/tags/cli"},{"label":"installer","permalink":"/blog/tags/installer"},{"label":"service","permalink":"/blog/tags/service"},{"label":"configuration","permalink":"/blog/tags/configuration"},{"label":"release","permalink":"/blog/tags/release"},{"label":"0.2.1","permalink":"/blog/tags/0-2-1"}],"readingTime":0.97,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Release 0.2.1","authors":"sudhindra","tags":["pyrsia","cli","installer","service","configuration","release","0.2.1"]},"nextItem":{"title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","permalink":"/blog/2022/10/10/why-does-pyrsia-use-a-blockchain"}},"content":"## Announcing a new release\\n\\nWe are happy to announce the release of [version 0.2.1](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.1) today!\\n\\nThis release has incremental improvements over the [version 0.2.0](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0) released at the CDSummit at Kubecon.\\n\\nOther than usual software quality improvements this release includes the following:\\n\\n* Better CLI experience - easy to configure\\n* MacOSX installer is able to start the service automatically - better experience for getting started.\\n* Automatically request builds on Pyrsia if an artifact does not exist on the network.\\n* Improved and updated documentation\\n\\n## Integration tests and Staging environment\\n\\nWe invested a lot of time in this release to improve our testing etiquette.\\n\\nWe now have a set of [integration tests](https://github.com/pyrsia/pyrsia-integration-tests) that we rely on to ensure that the network is stable and the functionality Pyrsia offers, continues to remain stable.\\n\\nWe did not have a dedicated infrastructure to test before going to production. As of this release we have a staging environment that allows us to test before we deploy to production.\\n\\nMore testing is better!\\n\\nPlease [download our installers](https://pyrsia.io/docs/tutorials/quick-installation/), try out Pyrsia with Docker and [let us know](https://pyrsia.io/docs/community/get_involved/) if you are looking for something Pyrsia does not support yet."},{"id":"/2022/10/10/why-does-pyrsia-use-a-blockchain","metadata":{"permalink":"/blog/2022/10/10/why-does-pyrsia-use-a-blockchain","source":"@site/blog/2022-10-10-why-does-pyrsia-use-a-blockchain.md","title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","description":"Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.","date":"2022-10-10T00:00:00.000Z","formattedDate":"October 10, 2022","tags":[{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"consensus","permalink":"/blog/tags/consensus"},{"label":"cryptocurrency","permalink":"/blog/tags/cryptocurrency"},{"label":"proof-of-work","permalink":"/blog/tags/proof-of-work"},{"label":"proof-of-stake","permalink":"/blog/tags/proof-of-stake"},{"label":"security","permalink":"/blog/tags/security"},{"label":"transparency","permalink":"/blog/tags/transparency"},{"label":"provenance","permalink":"/blog/tags/provenance"}],"readingTime":13.535,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","authors":"sudhindra","tags":["blockchain","consensus","cryptocurrency","proof-of-work","proof-of-stake","security","transparency","provenance"]},"prevItem":{"title":"Release 0.2.1","permalink":"/blog/2022/11/30/pyrsia-0.2.1-released"},"nextItem":{"title":"Why Pyrsia is being built in Rust?","permalink":"/blog/2022/09/30/why-pyrsia-is-being-built-in-rust"}},"content":"Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.\\n\\nBlockchain technology is deployed to leverage the following features:\\n\\n* Distributed ledger: Blockchain implementations use a distributed ledger and perform transactions based on consensus.\\n* Consensus based commits: Typically blockchain implementations come with an implementation of a Byzantine Fault Tolerance (BFT) * algorithm[1].\\n* Transparency and Immutability: Blockchain transactions are transparent and immutable, meaning they cannot be tampered with, thus * increasing trust and confidence in the system.\\n* Faster transactions: Third party verification is eliminated thus causing faster transactions.\\n* Improved security: Blockchain transactions embed security within them which can be verified by third parties. Any attempts at adding malicious data make the blockchain invalid thus exposing breaches.\\n\\nA software supply chain backed by a consistent verifiable ledger using blockchain brings trust into the open source software world. Also as blockchain commits are typically implemented based on BFT they provide security against failures in a distributed network. This provides protection against malicious network nodes committing data to the blockchain.\\n\\nIn this blog we discuss how Pyrsia is a tool for securing your software supply chain. We discuss the application of blockchain technology to provide an immutable record of each open source software being built into a binary. We further discuss how other aspects of blockchain technology help us build a distributed system that can scale across the globe.\\n\\n## Software Supply Chain Security\\n\\nSoftware supply chain has received much attention since a few well known events have affected the software industry and these have also percolated into real lives of people (eg. Equifax data breach[2], Solarwinds breach[3], Log4Shell vulnerability[4], Spring4Shell vulnerability[5] and many more).\\nSoftware supply chain has become a core topic of discussion within the software industry and also caused policy decisions[6] to solidify the security posture across the board.\\n\\nThe vulnerabilities discussed above and many more that go without receiving so much attention are discovered in the open source libraries that become part of the end user software. Much of this open source software development relies on few people\u2019s effort and on tools that do not give insight into how the said software is being built. Establishing any level of trust becomes a challenge. Furthermore, once this open source software becomes part of the supply chain, we rely on a lot of manual effort to determine the components that are part of the software supply chain.\\n\\n>\\n> Our proposal for Pyrsia [7], a decentralized package network, aims to provide a solution for a key part of the supply chain.\\n> Pyrsia aims to\\n>\\n> * Build trust for the open-source packages being used as dependencies in software development through certified and peer-verified builds\\n> * Provide a decentralized package network that understands package coordinates, semantics, and discoverability, and which continues to work even though there are local outages\\n>\\n\\nPyrsia aims to provide a tool to establish and verify trust in the software delivery world. With Pyrsia we hope to provide a source of information that can be used to automate much of this effort. 75% software comes from open source components[8] and with Pyrsia as the mechanism to manage these components we look towards a future where software is liquid[9].\\n\\nPyrsia aims to provide trustworthy provenance data which can be used to automate releases, patches and audit activities for the supply chain. Gathering all this information and sharing it with decentralized nodes requires a lightweight and tamperproof database.\\n\\nIn order to make Pyrsia\u2019s goals successful we need to use a database that can serve the following requirements:\\n\\n* Performant in a distributed setting\\n* Tamperproof\\n* Lightweight enough to be able to stream updates efficiently\\n\\nA blockchain implementation is a perfect fit since it provides all the above features and provides the ability to add verification mechanisms on top of it. Let\u2019s talk a little bit more about the current state of the software supply chain.\\n\\n## State of Software Supply chain\\n\\n### Lack of trustworthy provenance data\\n\\nAs it stands today we implicitly rely and trust the central repositories to provide updates to open source libraries. But evidence has shown that such implicit trust is not sufficient to secure the supply chain. There have been instances that show how this trust can be breached either by a rogue agent taking over control from the rightful owner (email squatting, typosquatting 1, typosquatting 2) or even the rightful owner turning rogue for some reason or getting burnt out.\\n\\nOverall building a definitive SBOM for your software continues to be a challenge. Querying to determine versions, related vulnerabilities, dependency chains and potential remediation still remains a manual process. Such manual processes are error prone and require investment of effort similar to that of building original software and thus do not get enough attention until disaster has struck.\\n\\nPyrsia started with a goal of building such a provenance log which is easy to use with automation, and scales across a distributed network.\\n\\nPyrsia aims to keep the nodes on the network up to date using a peer to peer update mechanism. This is critical so that many of the Pyrsia functions can be performed on the peer node without having to traverse. the network. The critical part here that needs to be upto date is the provenance log which is powered by the blockchain.\\n\\nThis provenance log will further support an automation infrastructure to aid software delivery decisions which currently requires manual intervention.\\n\\n### Dependence on centralized repositories\\n\\nRealizing that centralized repositories have run their course in terms of being a source of trust and reliability, we started the Pyrsia design with emphasis on being distributed by design.\\nWe need a distributed network since centralized repositories lack the reliability and scale that decentralized systems can provide.\\n\\nPyrsia relies on the peer-to-peer (P2P) communication mechanisms (think bittorrent) to exchange artifacts, metadata about those artifacts and also the provenance log. Pyrsia leverages two different channels to make these network transfers efficient. One channel delivers artifacts and another channel is used to synchronize the blockchain over the network. Artifacts are delivered on demand but the provenance log is updated frequently and this information needs to be lightweight - which is facilitated by the append-only blockchain. Leveraging the P2P technology makes Pyrsia resilient to internet failure modes (data center failures or network failures) and allows the network to scale organically - even across geographical boundaries where data center availability may be a challenge.\\n\\nBut using this technology also meant that Pyrsia could not rely on traditional data distribution mechanisms (like distributed databases, network caches, CDNs etc). Pyrsia needed a distributed database that was easy to update and transmit (read: serialize) over the network. Since P2P networks are also fault tolerant we needed to ensure that such a database can be usable from the local Pyrsia node (think git).\\n\\nGiven these constraints/requirements we started thinking about using a blockchain as a possible solution.\\n\\n### Trustworthy means tamperproof\\n\\nThe main feature that Pyrsia provides is a reliable and verifiable log for asserting your dependencies. This means that we need a log that is append only, written once and read many times and its entries to be immutable. We need a database that is tamper proof with guarantees of discovering and resolving any malicious additions. Blockchain technology has proved to be one of those immutable databases.\\n\\nHence we chose a Blockchain technology that acts as an immutable ledger for the purpose of storing all data related to artifacts. Furthermore as we mentioned before  Blockchain implementation requires a consensus mechanism based on BFT to ensure that there is security against taking over the network. An implementation of Blockchain implements BFT to ensure there is consensus for each block of data committed. BFT algorithms are resilient against network attacks that span the network and can tolerate upto \u2153 of the network failures. For a reasonable sized network getting control of \u2153 of the network nodes is a costly operation for hackers.\\n\\n## Pyrsia Design\\n\\n### Provenance Log\\n\\nPyrsia is built to provide a Provenance log to provide enough information about open source software. This information can be used to build decision making automation to enable releases and control what can be released. This provenance log is built to be lightweight so that a large number of software binaries can be tracked efficiently. In order to store such a provenance log we need a storage solution that has auditable and verifiable links that connect to history. Blockchain or immutable ledgers provide an efficient mechanism to store such chains of information and allow for quick retrieval.\\n\\nAnother feature Pyrsia is building is a search engine that can provide provenance log for each version, each binary type and each binary name. Pyrsia needs to parse this information quickly so that search indexes remain current at all times..Compared to the heavy footprint of the artifacts themselves the blockchain is much more lightweight and intends to keep itself that way. As the ecosystem grows this database will grow in size but still remain magnitudes smaller than the artifact storage.\\n\\n### Network Structure\\n\\nPyrsia\u2019s design contains a network structure that provides direct connectivity between peers thus allowing for immense scale. Having said that, given the emphasis on security we have a differentiation between nodes that run in the cloud and the ones that are run on individual/volunteer nodes. The nodes that run on the cloud have the ability to act as a large cache, have better network throughput thus providing a bigger conduit to reach the repositories. The volunteer nodes provide a P2P network, a sort of proxy cache to content and an effective distribution mechanism. The authority nodes are the only ones that can commit to the ledger and thus provide a trustworthy provenance log.\\n\\n![Pyrsia Network Design](/img/blog/provenance_log_architecture.png \\"Pyrsia Network\\")\\n\\nAlong with this the nodes on the cloud are deployed and maintained by Pyrsia governing organizations (Governing organizations are listed on <https://pyrsia.io/>). Having these owned by organizations instead of individuals enhances the availability of these nodes as well as vastly improves the security posture. We are now able to verify these nodes, provide identity mechanisms to have a provable chain of authority and provide membership privileges to keep the network secure - while scaling it across regions.\\n\\nThis network structure allows us another luxury, that of ensuring we control the data that is being committed to the blockchain. Early on we decided that Pyrsia will only allow the cloud nodes to commit to the blockchain using a consensus mechanism. This consensus mechanism will only allow authorized cloud nodes to commit and thus reduce the complexity of the consensus mechanism. Another aspect we realized is that, given Pyrsia will have very limited participants being able to commit to the blockchain we can stay away from the expensive, mining heavy, at times quite wasteful algorithms. Thus we steered clear from investing into the Proof of Work, Proof of Stake and similar algorithms. We have been focusing on using the Proof of Authority which has significantly reduced the complexity while providing us with sufficient control to keep the network secure.\\n\\nIn this design the authority is assigned and cannot be obtained through the means that are used on the open networks. Pyrsia governance organizations approve every node that has the authority to commit to the blockchain. This furthers our goal of providing a trustworthy network which has more control over what is available on the network. The Authority nodes are the only ones committing to the blockchain and then transmitting those updates to the peer nodes.\\n\\n## Leveraging the Blockchain technology\\n\\nGiven the above criteria and constraints and evidence of success of the blockchain technology we found that the right fit for Pyrsia\u2019s provenance log - which is its source of truth - using an implementation of blockchain technology was the right choice for Pyrsia.\\n\\nWe further assessed available implementations of blockchain and narrowed our choice of implementation based on the following criteria:\\nAvailability of multiple language support - especially good documentation for a Rust implementation\\nAbility to turn of or not have the concept of Currency to make transactions on the network\\nAbility to choose the consensus algorithms that fit Pyrsia\u2019s need and situation - Proof of Authority\\n\\nWe found that AlephBFT supported all these criteria and was easy to get started. We have been able to also build on top of AlephBFT to constrain the use cases of Pyrsia without giving away security. AlephBFT has also allowed us to configure the network nodes in a way that allows us the control we need to support the security.\\n\\n## Blockchain does not mean Crypto\\n\\nOne thing we have learnt over the course of this effort is that - whenever we talk about blockchain as the technology we use in Pyrsia, we have received critical feedback about how we are overcomplicating our design. When we reflected on this feedback we realized that the majority of it is due to the prevalent use of blockchain within the cryptocurrency world.\\n\\nBlockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it automatically gets associated with cryptocurrency and mining. And we have found that it is really hard to break this association. We also found that the most popular implementations connect the mining and crypto aspects to the blockchain in such a way that they become inseparable.\\n\\nBlockchain will act as the immutable ledger giving us the tamper proof database we need, with the ability to search it efficiently and distribute it across the peers as we need.\\n\\nPyrsia is open source and free. The key to ensuring that the open source community continues to engage and use Pyrsia is that there should not be any currency attached with actions on Pyrsia. From the get go this has been our main objective to keep this network free and open to use for the community and we have worked to implement an immutable ledger which does not have the concept of cryptocurrency in it. Our implementation has removed the requirement of requiring gas (a fuel to power your transactions on the blockchain) or currency for participation. Given the security concerns Pyrsia operates on a small number of Pyrsia nodes that participate in consensus. Running the Proof of Authority algorithm from certified nodes and limiting those number of nodes to the participants of the governing board, allows Pyrsia to maintain security without being open to any mining on the network. Pyrsia will also benefit from the lightweight implementation of AlephBFT so that we can scale across regions and keep the network always up to date.\\n\\nPyrsia aims to leverage blockchain to power the provenance data while not allowing any usage of cryptocurrency on the network. We believe that open source should be free to use and should not have incentives attached to it to allow for fairness. Pyrsia builds on the success of blockchain while saving resources (energy) by not allowing any competitive currency exchange on the network.\\n\\n## In Summary\\n\\nPyrsia leverages blockchain as an immutable ledger to provide a scalable provenance log. Blockchain technology is best suited for distributed large amounts of chained data across wide networks which is evidenced from the success of blockchain in the cryptocurrencies. Pyrsia is using this same technology to improve the state of the software supply chain by providing transparency into how open source software is being built on this network. This transparency is aimed to give you the confidence to use the open source library in your production environments.\\n\\n### References\\n\\n* [Byzantine Fault Tolerance](https://decrypt.co/resources/byzantine-fault-tolerance-what-is-it-explained)\\n* [Equifax data breach](https://www.synopsys.com/blogs/software-security/equifax-apache-struts-vulnerability-cve-2017-5638/)\\n* [Solarwinds breach](https://www.businessinsider.in/tech/news/heres-a-simple-explanation-of-how-the-massive-solarwinds-hack-happened-and-why-its-such-a-big-deal/articleshow/79945993.cms)\\n* [Log4Shell vulnerability](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)\\n* [Spring4Shell vulnerability](https://jfrog.com/blog/springshell-zero-day-vulnerability-all-you-need-to-know/)\\n* [Executive order on improving nations cybersecurity](https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/)\\n* [Pyrsia Proposal](https://pyrsia.io)\\n* [75% software comes from open source components](https://www.synopsys.com/software-integrity/resources/analyst-reports/open-source-security-risk-analysis.html?intcmp=sig-blog-rsa22)\\n* [Software is Liquid](https://jfrog.com/whitepaper/a-vision-of-liquid-software/)"},{"id":"/2022/09/30/why-pyrsia-is-being-built-in-rust","metadata":{"permalink":"/blog/2022/09/30/why-pyrsia-is-being-built-in-rust","source":"@site/blog/2022-09-30-why-pyrsia-is-being-built-in-rust.md","title":"Why Pyrsia is being built in Rust?","description":"When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.","date":"2022-09-30T00:00:00.000Z","formattedDate":"September 30, 2022","tags":[{"label":"rustlang","permalink":"/blog/tags/rustlang"},{"label":"rust","permalink":"/blog/tags/rust"},{"label":"security","permalink":"/blog/tags/security"},{"label":"web3","permalink":"/blog/tags/web-3"},{"label":"modern","permalink":"/blog/tags/modern"},{"label":"safety","permalink":"/blog/tags/safety"},{"label":"community","permalink":"/blog/tags/community"},{"label":"ecosystem","permalink":"/blog/tags/ecosystem"}],"readingTime":5.51,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Why Pyrsia is being built in Rust?","authors":"sudhindra","tags":["rustlang","rust","security","web3","modern","safety","community","ecosystem"]},"prevItem":{"title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","permalink":"/blog/2022/10/10/why-does-pyrsia-use-a-blockchain"},"nextItem":{"title":"Peer Metrics in the Pyrsia Network","permalink":"/blog/2022/06/03/peer-metrics"}},"content":"When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.\\n\\n## Securing Open Source Software\\n\\nOpen source software is built mostly by people passionate about solving a problem and sharing their solutions widely. One of the differences in how we build proprietary software vs open source is that we find that many of those original developers do their best in keeping the software upto date and try to patch vulnerabilities as soon as they can. Although their efforts are usually the best they can do. In some well publicized cases, developers have experienced burnout and lack of interest in supporting what they built, due to resource constraints.\\n\\nFor proprietary software, there are well published processes and patterns which are used to build software and record how it was done. Open Source software usually does not get this rigor and often is found vulnerable.\\n\\nOn Pyrsia we focus on this missing piece of building open source software and are building a platform that offers build from source service while providing a record of how it was done. Pyrsia leverages a peer-to-peer distribution model for these binaries thus making the network resilient to failures.\\n\\n### Secure Software needs a secure platform\\n\\nWhile the aim of Pyrsia is to secure the software that it builds, a lot of trust/community involvement expects the network itself to be secure. Pyrsia as a platform has taken this expectation seriously and from the initial days invested a lot of energy into building it right.\\n\\nA few other considerations that were made during the initial discussions of Pyrsia include:\\n\\n* Decentralized network (think Web3) to leverage distribution of binaries across regions\\n* Build from source using independent randomly chosen nodes to ensure security by reducing surface of attack\\n* Consensus mechanism to ensure that multiple nodes participate in the build and verification process\\n* Deploying Pyrsia node instances on wide variety of architectures, operating systems, as well as footprints(think Intel Xeon all the way to Raspberry * Pi and beyond)\\n* Ensuring wide deployments have a minimal footprint - for transportation, but more importantly to further reduce the possibility of attacks\\n* Modern software that allows system programming - to enhance experience and also to restrict how the data structures can be used. Constraining how the software is built is key to making it more secure.\\n\\n## Choosing a programming language\\n\\nFor Pyrsia to address the above considerations we weighed them against a few popular languages with decent community voice and size.\\n\\nSpecifically we were looking for the following in a programming language ecosystem:\\n\\n* Welcoming community - People come first\\n* Modern language constructs that help us focus on the problem instead of the language\\n* Secure or easily to build for security\\n* Multiple OS and Arch support\\n* Ability to drop down to lower level to help implement any cryptography, improve performance\\n* Support for web3 implementations like p2p networking, blockchain, cryptography\\n* Installed base of system software in the language\\n\\n[Rust](http://rustlang.org) seemed to satisfy all these requirements, in fact with flying colors.\\n\\n## RUST Language\\n\\n### Rust philosophy [1]\\n\\n> Today we are very proud to announce the 1.0 release of Rust, a new programming language aiming to make it easier to build reliable, efficient systems. Rust combines low-level control over performance with high-level convenience and safety guarantees. Better yet, it achieves these goals without requiring a garbage collector or runtime, making it possible to use Rust libraries as a \\"drop-in replacement\\" for C.\\n\\nWhat makes Rust different from other languages is its type system, which represents a refinement and codification of \\"best practices\\" that have been hammered out by generations of C and C++ programmers. As such, Rust has something to offer for both experienced systems programmers and newcomers alike: experienced programmers will find they save time they would have spent debugging, whereas newcomers can write low-level code without worrying about minor mistakes leading to mysterious crashes.\\n\\n### History of Rust [2]\\n\\n> Rust began as a side project of Graydon Hoare, an employee at Mozilla. In short order, Mozilla saw the potential of the new language and began sponsoring it, before revealing it to the world in 2010.\\nOne possible source of the name, according to Hoare, is the rust fungus. This has caused Rust programmers to adopt \u201cRustaceans\u201d as their moniker of choice.\\n>\\n> Despite its relative youth, Rust has steadily risen in the ranks of popular programming languages. In fact, while it ranked 33 in July 2019, by July 2020 it had risen to the 18th spot on the [TIOBE Programming Community Index](<https://www.tiobe.com/tiobe-index/>). Similarly, according to [Stack Overflow Developer Survey](https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved), Rust has been the `most loved` language since 2016.\\n\\n### Rust language ecosystem\\n\\nThe above philosophy made Rust a great candidate for use in security solutions like Pyrsia. Some other aspects that sealed the deal as a programming language for us were:\\n\\n* Performance close to equivalent C level programs [3]\\n* Concurrent programming without the garbage collection [4]\\n* Rust has a borrow checker which ensures references do not outlive the data\\n* Rust can be compiled to reduced instruction set architectures\\n\\nAlong with the above, we also found that the initial set of libraries(libp2p, AlephBFT) we were looking to support, had mature implementations in rust. Also we found that the communities that supported these libraries were welcoming all implementers and learners alike. This openness within the Rust community in general made the choice easier for us.\\nA lot of these appealing features of the Rust ecosystem are well summarized in [5].\\n\\n## Summary\\n\\nWhen we set out to change how open source software is secured we had a choice to make - the language to build the security solution with. When we surveyed what was available there were multiple options. C due to its performance, Golang because of its mature installations in the wild, Rust as an up and coming community with performance and modern language features.\\n\\nIn the end it was clear to us that Rust was the right choice to make and we have started building Pyrsia in Rust. We realize that we have a steep learning curve and we are learning as a group. Come join us on our [Slack channel](https://cdeliveryfdn.slack.com/join/shared_invite/zt-1eryue9cw-9YpgrfIfsTcDS~hGHchURg) to discuss more.\\n\\n### References\\n\\n* [Rust Philosophy](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html)\\n* [Rust History](https://www.talentopia.com/news/the-rust-programming-language-its-history-and-why/)\\n* [Rust vs C](https://codilime.com/blog/rust-vs-c-safety-and-performance-in-low-level-network-programming/)\\n* [Garbage collection issues](https://discord.com/blog/why-discord-is-switching-from-go-to-rust)\\n* [Why projects use Rust?](https://codilime.com/blog/why-is-rust-programming-language-so-popular/#:~:text=High%20performance%20and%20safety%20are,amounts%20of%20data%20very%20quickly)"},{"id":"/2022/06/03/peer-metrics","metadata":{"permalink":"/blog/2022/06/03/peer-metrics","source":"@site/blog/2022-06-03-peer-metrics.md","title":"Peer Metrics in the Pyrsia Network","description":"Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and \\"fast\\". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.","date":"2022-06-03T00:00:00.000Z","formattedDate":"June 3, 2022","tags":[{"label":"p2p","permalink":"/blog/tags/p-2-p"},{"label":"peer-metrics","permalink":"/blog/tags/peer-metrics"}],"readingTime":4.145,"hasTruncateMarker":false,"authors":[{"name":"Mark Seaborn","title":"Pyrsia Contributor","image_url":"https://github.com/mseabornIBM.png","imageURL":"https://github.com/mseabornIBM.png"}],"frontMatter":{"title":"Peer Metrics in the Pyrsia Network","authors":[{"name":"Mark Seaborn","title":"Pyrsia Contributor","image_url":"https://github.com/mseabornIBM.png","imageURL":"https://github.com/mseabornIBM.png"}],"tags":["p2p","peer-metrics"]},"prevItem":{"title":"Why Pyrsia is being built in Rust?","permalink":"/blog/2022/09/30/why-pyrsia-is-being-built-in-rust"},"nextItem":{"title":"Blockchain Consensus","permalink":"/blog/2022/01/28/blockchain-consensus"}},"content":"Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and \\"fast\\". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.\\n\\nHerein I present the mechanism the Pyrsia team has created to help improve the selection process for downloading software distributions from peers. The idea is to improve upon the Kademila peer selection process and make \\"smarter\\" choices from Pyrsia peers based on a \\"peer metric\\". The mechanism is layered atop the Kademila peer selection process, which in Pyrisa returns a list of peers known to be in possession of an open-source distribution of interest. The peer metric is a real time assessment of the work-load of any given machine in the network, both related and unrelated to any current software transfers within the Pyrsia network.\\n\\nThe following table defines terms used in this blog.\\n\\n|Term|Definition|\\n|---|---|\\n|Requester|In this context a requestor is a Pyrsia client requesting a file to be downloaded or uploaded to/from its peer(s).|\\n|Peer (Pyrsia Peer)|Any Pyrsia client that is participating in the network.|\\n|Neighboring Node|Any node that is returned by the Kademila algorithm as having a software distribution desired by a peer.|\\n\\nAs previously stated, a primary goal of the peer-to-peer software distribution sharing function of Pyrsia is that it efficiently uses peers. The efficient use of peers can be broken down into two aspects, efficiencies related to uploading software distributions to peers and efficiencies related to downloading software distributions from peers. This post limits the discussion to downloading software distributions from peers.\\n\\nThe primary rule defined by our selection process is that requesters must not overwhelm peers by requesting too many software distributions too often from any one neighboring node. Though hard resource usage limits are a configuration function for Pyrsia Peers, Pyrsia\u2019s peer selection mechanism should also attempt to balance requests across the network of peers. Additionally, the peer selection mechanism should operate such that file requesters are not starved for bandwidth in the network by unresponsive peers, preventing fast downloads. While the first efficiency could be guaranteed by Pyrsia policy, the second one is more nebulous because Pyrsia cannot guarantee enough stable network peers exist at request times to achieve \u201cfast downloads\u201d.\\n\\nThe terms \u201cfast downloads\u201d and \u201crequesting too much data\u201d must be further defined to quantify what is meant. The means of describing these terms can be defined as a function of the attributes within the environment. There are measurable attributes of both the network and the Pyrsia peers participating in the networks that can help us define metrics to balance requests. These metrics will ultimately determine the quality of peers in the requesters\' peer list. The term quality in this context is related to the ability of a peer to satisfy a request for download and will be defined by the function Q(x):\\n\\n![$Q(x) = \\\\sum_{n=1} ^{pa\\\\ count} pa_n * weight](https://latex.codecogs.com/svg.image?Q(x)&space;=&space;\\\\sum_{n=1}&space;^{pa\\\\&space;count}&space;pa_n&space;*&space;weight)\\n\\nwhere `pa` is a peer attribute of the environment and `weight` is a number that determines the expense of the attribute. The quality number will be calculated on demand by peers returned in the list of peers generated by the Kadimela algorithm. The quality function can be used for either upload quality or download quality depending on the need. The metric is currently used during the selection process for downloading software distributions. Finally, we need to define what characteristics are important to drive analytics for decisions about transactions on the network. The following table lists the attribute used by to Pyrsia generate the peer metric in Pyrsia. The peer with the lowest number is considered to be the ideal candidate for the software distribution download.\\n\\n|Peer Attribute|Definition|\\n|---|---|\\n|Peer Network Load|A measurement of the current network bandwidth usage in terms packets in and packet out summed over all network interfaces.|\\n|CPU Load|The average CPU load over the last minute|\\n|Disk I/O Load|A measure of the current packets being read and written summed over all current processes on the system|\\n\\nThis system of measuring the quality of peers will evolved over time and as other attributes are defined, they will be integrated into the Pyrsia network."},{"id":"/2022/01/28/blockchain-consensus","metadata":{"permalink":"/blog/2022/01/28/blockchain-consensus","source":"@site/blog/2022-01-28-blockchain-consensus.md","title":"Blockchain Consensus","description":"Blockchain technologies are trending. There\u2019s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.","date":"2022-01-28T00:00:00.000Z","formattedDate":"January 28, 2022","tags":[{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"consensus","permalink":"/blog/tags/consensus"},{"label":"bitcoin","permalink":"/blog/tags/bitcoin"},{"label":"ethereum","permalink":"/blog/tags/ethereum"},{"label":"proof-of-work","permalink":"/blog/tags/proof-of-work"},{"label":"proof-of-stake","permalink":"/blog/tags/proof-of-stake"}],"readingTime":6.55,"hasTruncateMarker":false,"authors":[{"name":"Christopher McArthur","title":"Pyrsia Contributor","image_url":"https://github.com/prince-chrismc.png","imageURL":"https://github.com/prince-chrismc.png"}],"frontMatter":{"title":"Blockchain Consensus","authors":[{"name":"Christopher McArthur","title":"Pyrsia Contributor","image_url":"https://github.com/prince-chrismc.png","imageURL":"https://github.com/prince-chrismc.png"}],"tags":["blockchain","consensus","bitcoin","ethereum","proof-of-work","proof-of-stake"]},"prevItem":{"title":"Peer Metrics in the Pyrsia Network","permalink":"/blog/2022/06/03/peer-metrics"}},"content":"Blockchain technologies are trending. There\u2019s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.\\n\\n## What is a Blockchain\\n\\nIBM has one of my [favorite definitions](https://www.ibm.com/topics/what-is-blockchain):\\n\\n>\xa0Blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets \\\\[... on] a network.\\n> An asset can be tangible (a house, car, cash, land) or intangible (intellectual property, patents, copyrights, branding). Virtually\\n> anything of value can be tracked \\\\[... ] on a blockchain network, reducing risk \\\\[...] for all involved.\\n\\nThere\u2019s a few key items to highlight from this definition are:\\n\\n- A shared, immutable ledger\\n- Recording and tracking assets\\n\\nSimply put, a Blockchain is a list of changes to assets, called transactions, which are grouped in blocks that are recognized by all participants in the network.\\n\\nUnfortunately, it leaves out one major element. How do blockchain networks reduce risk? How do blockchain networks agree on the shared ledger?\\n\\n## Consensus\\n\\nIn the world of blockchain, consensus is the agreement of which block is next. Collectively all the participants in the blockchain\u2019s network\\nshould come to the same conclusion.\\n\\nYou\u2019ve probably heard of \u201cProof of Work\u201d, usually called mining, and \u201cProof of Stake\u201d, these two are the most popular in terms of market share\\nin the crypto markets.\\n\\nThese consensus algorithms were some of the first to be popularized by projects like Bitcoin and Ethereum. These are far from the only ones, Proof of Authority, Proof of Burn, Proof of Capacity and Proof of History are just from others mentioned on [Investopedia\'s Website](https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp).\\n\\nLet\u2019s dive deeper into the two popular algorithms to see how they obtain consensus.\\n\\n### Proof of Work\\n\\nProof of Work is based on a mathematical expression which is very costly to compute a magic number, called a nonce, but easily verified. Each participant, typically referred to as a miner, begins the calculation with the transitions it\u2019s heard on the network since the last published block. Participants race each other to find the right answer and the winner traditionally gets a reward. It\u2019s difficult to cheat and very rewarding to operate in good faith.\\n\\nAt the time of writing, January 28th 2022, the reward is 6.25 BTC which is worth 236,755 USD. It\u2019s easy to draw parallels to the 1849 Gold Rush.\\n\\n![BitCoin Value](https://lh4.googleusercontent.com/lbGxZlJRF5GlNLNmbQlnS7Rdk0CHU9w2QjyfghfFLKWOa-bz7ZaEq83AWwVwEd4oJXZgUhyBQxzZ_-_6ytuISeQXU1er77nfwYpdoPgaE_8bvQqKFdsLmUVRbuc9NrePRDTtcZ7YbkqgTq5RMg)\\n\\nWhen miners hear of a new block, they immediately stop their calculation and begin listening for more transactions. This is approximately a 10 minute window for Bitcoin.\\n\\nWith a small number of competitors it\u2019s pretty straightforward but when tens of thousands of nodes are involved, what happens if two miners finish at the same time. Who wins?\\n\\n### Proof of Stake\\n\\nProof of Stake is an investment strategy where committing more capital means you\u2019re more likely to get the reward. [Peercoin](https://www.peercoin.net/whitepapers/peercoin-paper.pdf), a very early PoS implementation, kept the mining of PoW but required less computational complexity the more _coinage_ was staked. If two participants offer the same investment in the next block, which one is rewarded?\\n\\nIf someone is able to offer more capital for their block to be accepted, are they able to always win? Yes, this is a special type of security exploit called a 51% attack. If the confirmation of the next block is tied to a resource, then an entity which holds a majority stake can take control of the blockchain. Proof of Work is also susceptible to this type of attack.\\n\\n### Stale and Orphan Blocks\\n\\nMost blockchain\u2019s are actually trees, not linked lists which is what probably comes to mind for young data scientists. This probably comes as a shock but it\u2019s the secret ingredient to solving our racing condition when two participants propose the next block in PoW.\\n\\n> If two nodes broadcast different versions of the next block simultaneously, some\\n> nodes may receive one or the other first. In that case, they work on the first one they received,\\n> but save the other branch in case it becomes longer.\\n> The tie will be broken when the next proof-of-work is found and one branch becomes longer.\\n\\n[_Bitcoin: A Peer-to-Peer Electronic Cash System Section 5_](https://bitcoin.org/bitcoin.pdf)\\n\\nChains are made of links that connect to others. This data structure is referred to as a linked list, when a link\\npoints to both it\u2019s parent and child is a doubly linked list. Three sequential blocks being published would make the following chain:\\n\\n```mermaid\\nstateDiagram-v2\\n    [*] --\x3e Block_1\\n    Block_1 --\x3e Block_2 : Parent\\n    Block_2 --\x3e Block_3 : Child\\n    Block_3 --\x3e [*]\\n```\\n\\nIf block 4 was published at the same time as our block 3 a node would have the following tree:\\n\\n```mermaid\\nstateDiagram-v2\\n    [*] --\x3e Block_1\\n    Block_1 --\x3e Block_2 : Parent\\n    Block_2 --\x3e Block_3 : Child\\n    state Block_2 <<fork>>\\n        Block_2 --\x3e Block_4 : Nephew\\n        Block_3 --\x3e Block_5\\n    Block_5 --\x3e [*]\\n```\\n\\nSince it\u2019s extremely unlikely that a second pair of blocks would also be published at the same time, the tie is broken when the next sequential block is published. This is block 5 in the diagram above.\\n\\n#### Which branch should we follow\\n\\nWell, intuitively the \u201cstrongest\u201d branch of our tree is the one we should stick with. The strength comes from the amount of work that has gone into making the branch. More work means it\u2019s less likely that someone has cheated or lied.\\n\\n### Dynamic Validator Sets\\n\\n[Ethereum\u2019s new PoS system named _Consensus Layer_](https://ethereum.org/en/upgrades/merge), [formally Ethereum 2.0](https://blog.ethereum.org/2022/01/24/the-great-eth2-renaming/), is still in development but it\u2019s leading implementation is [Casper FFG](https://arxiv.org/pdf/1710.09437.pdf)\xa0[<sup>\\\\[2\\\\]</sup>](https://eips.ethereum.org/EIPS/eip-1011) (there\u2019s also [this](https://vitalik.ca/general/2018/12/05/cbc_casper.html) alternative) which uses a Byzantine Fault Tolerance consensus.\\n\\nIn Proof of Stake, the participants are called validators who\u2019s role is similar to miners in Proof of Work. The validator is staking money on the block that it thinks should be added to the chain. If the block gets appended, then they get a reward that is proportional to the bet that they placed on the block. [<sup>\\\\[1\\\\]</sup>](https://www.chubbydeveloper.com/ethereum-proof-of-stake-casper-ffg-vs-casper-cbc/)<sup> </sup>Validators are responsible for following the forking rules when staking checkpoints. Validators decide which block is the best by following a set of rules.\\n\\n<https://arxiv.org/pdf/1710.09437.pdf>\\n\\nThe proposal set the stake deposit at 32 ETH to be eligible to act as a validator. At the time of writing that has a value of 81,374.81 USD even after a recent drop in value.\\n\\n![ETH Value](https://lh6.googleusercontent.com/yqYvnvnQNbf46dzgQQcndXR8eFjm_LYe-6ND4GslxLlyxtZamkv5q6deQjMVayYz9cHNvzh8UbOwcl4Q897KJEJp_mtCHi0x3WvMWN8b9cG-1zDiLnuQ-lQiBaC2H6D66O-8x2umwhzTkWLbJA)\\n\\nThere\u2019s a few key concepts employed in Casper FFG, many are outlined in the [EIPS 1011\u2019s Glossary](https://eips.ethereum.org/EIPS/eip-1011#glossary)\\n\\n- Checkpoint is the block in the finalization stage\\n- Epoch is the range of blocks between checkpoints. This grow by one block for each new epoch\\n- Dynasty refers to the number of finalized checkpoints in the chain. (Note: checkpoints do not reach finality unless a super-majority of votes are obtained in favor)\\n\\nThe validators are _randomly_ selected (this is not detailed in the proposals but details are available [here](https://github.com/ethereum/casper/blob/4adeffce5709fcf2d36f4bc6ac27bbd62747d032/VALIDATOR_GUIDE.md)) based on who has deposited the correct funds. Participants must deposit the correct sum 2 dynasties in advance to join a validator set. In order to leave they must send a withdrawal request 2 dynasties in advance, however the funds are not returned for approximately 4 months since the withdrawal was requested.\\n\\nConsensus, or finality, is not reached unless \u2154, a super-majority of votes have been gathered stating the checkpoint meets the forking rules \u201cfollow the chain containing the justified \\\\[block] of the greatest height\u201d.\\n\\nWhen a checkpoint is finalized all the blocks in it\u2019s epoch are implicitly finalized as well. This also marks the start of a new dynasty, casting the previous on to history it can no longer be modified and reaches immutability. This is also when validators can enter or exit the staking on checkpoints.\\n\\n## References\\n\\n<https://developer.bitcoin.org/devguide/p2p_network.html?highlight=stale%20orphan#orphan-blocks>\\n\\n<https://developer.bitcoin.org/devguide/block_chain.html?highlight=stale#block-height-and-forking>\\n\\n<https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/>\\n\\n<https://vitalik.ca/general/2017/12/31/pos_faq.html>\\n\\n<https://medium.com/unitychain/intro-to-casper-ffg-9ed944d98b2d>\\n\\n<https://medium.com/@ppio/consensus-byzantine-fault-tolerance-402258ec7a60>\\n\\n<https://ethresear.ch/t/casper-ffg-with-one-message-type-and-simpler-fork-choice-rule/103/31>"}]}')}}]);