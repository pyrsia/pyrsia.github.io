"use strict";(self.webpackChunkpyrsia=self.webpackChunkpyrsia||[]).push([[1477],{30010:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/01/13/pyrsia-0.2.3-released","metadata":{"permalink":"/blog/2023/01/13/pyrsia-0.2.3-released","source":"@site/blog/2023-01-13-pyrsia-0.2.3-released.md","title":"Release 0.2.3","description":"Announcing First Release of 2023","date":"2023-01-13T00:00:00.000Z","formattedDate":"January 13, 2023","tags":[{"label":"pyrsia","permalink":"/blog/tags/pyrsia"},{"label":"rust","permalink":"/blog/tags/rust"},{"label":"onboarding","permalink":"/blog/tags/onboarding"},{"label":"upgrade","permalink":"/blog/tags/upgrade"},{"label":"0.2.3","permalink":"/blog/tags/0-2-3"},{"label":"release","permalink":"/blog/tags/release"}],"readingTime":1.335,"hasTruncateMarker":false,"authors":[{"name":"Manas Das","title":"Pyrsia Contributor","imageURL":"https://github.com/dasmanas.png","key":"manas_das"}],"frontMatter":{"title":"Release 0.2.3","authors":"manas_das","tags":["pyrsia","rust","onboarding","upgrade","0.2.3","release"]},"nextItem":{"title":"Authority Nodes","permalink":"/blog/2023/01/05/authority_nodes"}},"content":"## Announcing First Release of 2023\\n\\nHere we wish a Happy New Year 2023 to all contributors, sponsors, CDF community, followers and the DevOps community\\nmembers. In this year we will continue on our mission to solve a few high stake issues in Software Supply Chain.\\n\\nWe are happy to announce the release of [version 0.2.3](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.3) today!\\n\\nWe are our continued journey on a small & frequent release schedule. This is to allow us to release consistently and in\\nsmall increments as we decided.\\n\\nHere are a few salient features we added to the release:\\n\\n* Improved release docs with manual more test plan to ensure more confidence on the release and to provide more\\ntransparency.\\n* A new operation to Pyrsia CLI to remove configuration completely to get a default config automatically as soon as we\\ninitiate a get through various way.\\n* To provide better onboarding experience to new contributors, we made some significant onboarding doc updates to help\\nwith the understanding of Pyrsia and different toolset and framework we are using.\\n* In GitHub build pipeline we pinned Windows and OS X version to be more definitive.\\n* Using libp2p\'s GossipSub to distribute blocks among peers in more robust fashion.\\n* Blocked any openssl direct & transitive dependency to avoid clash with ssl provided by the platform.\\n\\nHere is a list of features we hope to cover in the upcoming release. They are listed as part of\\n[the milestone definition](https://github.com/pyrsia/pyrsia/milestone/9).\\n\\nPlease [download our installers](https://pyrsia.io/docs/tutorials/quick-installation/), try out Pyrsia with Docker and\\n[let us know](https://pyrsia.io/docs/community/get_involved/) if you are looking for something Pyrsia does not support\\nyet."},{"id":"/2023/01/05/authority_nodes","metadata":{"permalink":"/blog/2023/01/05/authority_nodes","source":"@site/blog/2023-01-05-authority_nodes.md","title":"Authority Nodes","description":"Pyrsia builds consensus based on Proof of Authority which is exercised by the Authority Nodes. Authority nodes are run by trusted Partner organizations who join the Pyrsia community and decide to contribute to the network. More about this architecture was detailed in a the Network Structure of Pyrsia.","date":"2023-01-05T00:00:00.000Z","formattedDate":"January 5, 2023","tags":[{"label":"authority","permalink":"/blog/tags/authority"},{"label":"consensus","permalink":"/blog/tags/consensus"},{"label":"proof of authority","permalink":"/blog/tags/proof-of-authority"},{"label":"cloud","permalink":"/blog/tags/cloud"},{"label":"deployment","permalink":"/blog/tags/deployment"},{"label":"immutable ledger","permalink":"/blog/tags/immutable-ledger"},{"label":"BFT","permalink":"/blog/tags/bft"},{"label":"security board","permalink":"/blog/tags/security-board"}],"readingTime":3.83,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Authority Nodes","authors":"sudhindra","tags":["authority","consensus","proof of authority","cloud","deployment","immutable ledger","BFT","security board"]},"prevItem":{"title":"Release 0.2.3","permalink":"/blog/2023/01/13/pyrsia-0.2.3-released"},"nextItem":{"title":"Pyrsia Anniversary Recap","permalink":"/blog/2022/12/30/pyrsia-anniversary-recap"}},"content":"Pyrsia builds consensus based on Proof of Authority which is exercised by the Authority Nodes. Authority nodes are run by trusted Partner organizations who join the Pyrsia community and decide to contribute to the network. More about this architecture was detailed in a the [Network Structure of Pyrsia](/blog/2022/10/10/why-does-pyrsia-use-a-blockchain/#network-structure).\\n\\nAuthority nodes act as the only legal votes in the Proof of Authority to achieve Consensus on Pyrsia blockchain. Authority nodes are assigned keys to prove membership and they vote using those keys to verify packages on the Pyrsia network. These assigned keys are controlled and regenerated by the Pyrsia governance board. We explain here the process and the technology required to implement this.\\n\\n## Pyrsia Security Board\\n\\nPyrsia project is working towards the concept of having a group of representatives forming a Security Board to ensure the security of the network and the artifacts served by the network. This board will have the scope of providing process and oversight over the following:\\n\\n1. Pyrsia Network Architecture\\n2. Pyrsia Network Security\\n3. Pyrsia Blockchain Security\\n4. Pyrsia DevOps Practices\\n5. Pyrsia Build Infrastructure Security\\n\\nWithin the above scope the Security Board will provide a uniform review and regulation process to ensure that rogue elements are not able to control the network. This Security board will be formed with the representative organizations to Pyrsia via an election process.\\n\\nAs part of the normal functioning of this board, the Pyrsia infrastructure will be evaluated periodically and certified.\\n\\nDetails of this process will be documented separately under the Community section of the [Pyrsia website](https://pyrsia.io).\\n\\n## Participating Authority Nodes\\n\\nAny participating organization to Pyrsia is welcome to join the network and host/sponsor hosting an Authority node.\\nAlthough Authority nodes will require the approval of the Pyrsia Security Board. Once approved the sponsor of the authority node will have the following responsibilities:\\n\\n1. Sponsor the cloud account and billing to host a large size Pyrsia Authority node - specifications will be provided and updated by the Security Board\\n2. Sponsor and provide DevOps personnel to maintain, update and repair the Pyrsia Authority node\\n3. Submit audit reports to the Security Board to ensure that the Authority node remains secure\\n\\nSince Pyrsia Authority Node is open source - the source code, helm charts, deployment processes will be maintained by the Pyrsia team thus making it  easy to install and run the Pyrsia Authority Node in the cloud environment of choice.\\n\\n## Participate in Proof of Authority\\n\\nOnce the infrastructure is up and running on the cloud, the Pyrsia nodes become part of the Pyrsia libp2p network and can download, search the Pyrsia network. In order to make these Pyrsia nodes part of the Consensus network this deployment will require some way to gain that authority.\\n\\nSince we need to maintain a small but reliable and tamper-proof network access to authority will be limited. Only the participating organizations will have the ability to contribute authority nodes. A people driven process will be in place that determines the readiness of this new participating organization. The security board will drive this process and lay out guidelines to make it transparent.\\nThe security board will also have the ability to assign authority keys to new participant organizations so that they can become part of the consensus process. Only approved Authority Nodes get an authority key.\\n\\nEach organization will receive one key that will allow them to participate in voting and publishing packages to the network. This publishing process will allow them to commit new versions of packages or new packages to the Pyrsia network.\\n\\nSecurity Board also reserves the right to revoke authority keys in case the keys or the authority nodes themselves get compromised. Security Board will review the devops practices periodically and suggest a refresh of the authority keys to ensure continued security of the immutable ledger.\\n\\n## Growing the network\\n\\nPyrsia released the first working version of the network in our [0.2.0 release](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0) which included an Authority node hosted by JFrog. We are working towards adding another Authority node that will run on a different cloud provider\'s infrastructure and will be releasing it soon.\\n\\nWhile we improve the infrastructure, we are also encouraging organizations to become part of the Pyrsia network and contribute Authority nodes and infrastructure to the network. If you are one of those organizations we would love to chat with you. Our goal is to make this network as distributed as possible - which allows Pyrsia artifacts to reach all the corners of the known internet as well as helps to keep the network running.\\n\\nDon\'t hesitate to reach out to us!"},{"id":"/2022/12/30/pyrsia-anniversary-recap","metadata":{"permalink":"/blog/2022/12/30/pyrsia-anniversary-recap","source":"@site/blog/2022-12-30-pyrsia-anniversary-recap.md","title":"Pyrsia Anniversary Recap","description":"It is hard to believe, but it has happened nevertheless. We have successfully completed a year around the sun, Pyrsia and the team that works on it. And what a year it has been.","date":"2022-12-30T00:00:00.000Z","formattedDate":"December 30, 2022","tags":[{"label":"supplychain","permalink":"/blog/tags/supplychain"},{"label":"security","permalink":"/blog/tags/security"},{"label":"recap","permalink":"/blog/tags/recap"},{"label":"stable","permalink":"/blog/tags/stable"},{"label":"releases","permalink":"/blog/tags/releases"}],"readingTime":11.915,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Pyrsia Anniversary Recap","authors":"sudhindra","tags":["supplychain","security","recap","stable","releases"]},"prevItem":{"title":"Authority Nodes","permalink":"/blog/2023/01/05/authority_nodes"},"nextItem":{"title":"Release 0.2.2","permalink":"/blog/2022/12/20/pyrsia-0.2.2-released"}},"content":"It is hard to believe, but it has happened nevertheless. We have successfully completed a year around the sun, Pyrsia and the team that works on it. And what a year it has been.\\nFrom lots of uncertainty, answering difficult questions, working with the Linux foundation, getting ready for CD Foundation, becoming part of CD Foundation and being able to consistently deliver new functionality. I want to take this opportunity to make note of some of the beautiful moments in the last year and wishing for more of those in the future.\\n\\n## All about the Supply chain\\n\\nIt all began with some initial ideas from Stephen Chin(@steveonJava) where the goal was to do something about the state of supply chain security. This came with a background in Devops where we witnessed many organizations either facing similar problems as those in the case of the SolarWinds attack or worrying about them. In both cases the confidence in software build processes was taking a hit. With the mission of improving the transparency in the supply chain we put together a proposal to kickoff Pyrsia. In the initial days we were juggling multiple conflicting requirements - where are we going to store those artifacts, how do we verify them, will the network be resilient to attacks, how we will deploy, and many many more.\\n\\nWe saw many organizations big and small jump on the Supplychain Security hashtag and start making some noise about its seriousness. What we witnessed was that these efforts started with big hearts and focused mostly on some kind of cryptography to secure the output of the supply chain. As we looked more closely at the problem we started noticing that the core issue was not about the output but *how* the output came about. Questions that we pondered were : What about the process that went into identifying what is being built? How about the build process itself? How do we verify the integrity? and so on.\\n\\nPyrsia started with taking all those into consideration and building a process to generate the desired artifacts. Pyrsia contained the promise of building from source, providing transparency and resilience from network failures or attacks. As we started understanding our mission in the early days we were starting to answer some of the above questions and also the ones that were raised during the implementation. Largely as I remember the first few weeks were spent questioning the fundamentals over building something. As we started getting more insight and as we tinkered with Rust some of the ideas were maturing and getting ready to be built into real software.\\n\\n## Security taken for granted\\n\\nBefore the SolarWinds attack and widespread news attention it received, security was taken for granted. Open source software continues to be built by individuals using trust metrics that work in real life. These trust mechanisms like `sharing commit access/publish rights, with other contributors was a widespread community practice` listed in [Rise of few-maintainer projects](https://increment.com/open-source/the-rise-of-few-maintainer-projects/) create a weak infrastructure that all software projects rely on. This worked as long as the awareness as well as impact was limited. With growing reliance on software from keeping the lights on to keeping us healthy and everything in between, this model of *trust* does not scale.\\n\\nPyrsia started to challenge this status quo and provide a better, available, transparent supply chain for your software.\\n\\n## Navigating the technology space\\n\\nIn the initial days the mission was getting clearer while we were researching and prototyping Everything!. Everything included - networking technologies, blockchain ledgers and technologies, programming in Rust and putting it all together. As we did this we were able to identify goals that we could incrementally build towards. We started with the aim of building a working version of the decentralized network that would let users download packages from peers. With this as our minimal requirement we experimented with different tools that could help us deliver.\\n\\n### Learning Rust\\n\\nAs we talked about our choice of language for this effort, Rust was something we started to learn and gain some experience with. As with any new language we found similar struggles while starting out with Rust. Initial days were mostly frustrations around the syntax and the toolchain. Although as we reflected on our struggles we realized that some of the typical decisions that triggered debates were already in place - for eg. how we organize Rust code, how the toolchain can be used, code linting and code organization. [The Rust Programming Language Book](https://doc.rust-lang.org/book/) was quite useful in guiding us along and answering some of our questions about building an idiomatic Rust codebase.\\n\\nAs I reflect on how we have learnt Rust I would say we complained, we got tired of complaining, we made peace with Rust and now our ride is getting smoother. I would say there are still situations which stump us from time to time, but they prove to be more educational instead of frustrating as they were before.\\n\\nI was able to talk more about Rust language and our journey so far at the recent [Rust London Meetup](https://www.meetup.com/rust-london-user-group/events/289909563?utm_medium=referral&utm_campaign=share-btn_savedevents_share_modal&utm_source=link).\\n\\n### Decentralized Network - libp2p\\n\\nFinding the right open source project that can help us build a decentralized network was a new challenge for us. At least one of our team members had some interest and background in networking(although it turns out experience building networking hardware helps, but there is still a lot of learning when it comes to networking software stack). So we started our research and landed on the [ipfs project](https://ipfs.io). This team had been doing some great working in building a scalable decentralized network using peer-to-peer networking. Incidentally a lot of their examples and experiments happen in Javascript and Golang. But to our pleasant surprise we were able to find the [libp2p](https://libp2p.io/) library was already being built in Rust and very close in feature set vis-a-vis the Golang implementation. This was great news for us - in that it would save us valuable energy and time in porting or rewriting existing software.\\n\\nAlthough, libp2p integration was not simple. We went through some cycles trying to understand selecting the feature set that was minimal and required for Pyrsia. As we continue using libp2p we are getting a better understanding of how it is being built as well as understand how it could be improved. libp2p community has made it easy to interact and has given us a warm welcome to their architecture meetings and general discussion.\\n\\nMost recently Elliott was able to attend the libp2p day at the ipfs.camp and [talk about Pyrsia and its use of libp2p to conquer the world](../blog/2022-12-20-using-libp2p-to-take-over-the-world-2022-ipfs-camp.md).\\n\\n### Immutable ledger\\n\\nPyrsia design had the concept of the transparency log(aka provenance log) from the early iterations. In our view, trust can only be based on transparency and this transparency needs to be protected.\\nOur research for the blockchain as the immutable ledger yielded some key metrics [that separated us from the popular use of blockchain - cryptocurrency](../blog/2022-10-10-why-does-pyrsia-use-a-blockchain.md). With our specific needs and limited scale(significantly limited if you think about the number of nodes involved in decision making) we decided to limit new blocks get added to the blockchain. Every transaction needed to be lightweight to enable limited network traffic and quick transport.\\n\\nMost of our research took us to opensource blockchain implementations that were based on/being used for some cryptocurrency purposes. Popular implementation like [Substrate](https://substrate.io/) were easy to get started and very user friendly. Although, this specific one tied us tightly to their implementation and the use of some concept of Gas(currency). This forced us to have an incentive mechanism based on currency thus hence rely on some cryptocurrency. None of these constraints make this a usable solution for open source. Pyrsia is intended to be community owned and governed. This does not bode well for a solution that forces a currency and thus an option for anyone to boost their stake by pumping more currency into the system. So Substrate and similar options were not an option for us.\\n\\nAs we continued to look for solutions that allow us to remain currency free and are built in Rust, we found AlephBFT - an implementation of the Byzantine Fault Tolerance algorithm for consensus. This seemed to be something we could use and work without being burdened by aspects of CryptoCurrency. This was a good sign again since we did not have to build a solution from the ground up.\\n\\n## Building the Prototype\\n\\nBuilding a prototype was still a challenge because it involved integrating these three things together - Rust, libp2p and AlephBFT. We started with the most basic version of the blockchain that determines consensus based on round robin of the participating nodes. For libp2p, we started with the most generic implementation and learnt our way through tuning it. The interesting part was making it work in Rust using the async mechanisms available. It took us a while to get to a working solution that did not crash on start. We still had memory leak issues that cause different behaviour after we ran the node for a while.\\n\\nWe were able to resolve some of those errors slowly by moving to a more stable and supported `tokio.rs` library for all our async processing. Tying it together libp2p made the memory leak go away and provide lot more stability that we had in the previous version.\\n\\nWhen we had it all working we released a [Demo Pyrsia network](https://github.com/pyrsia/pyrsia/releases/tag/v0.1.0).\\n\\n> Releasing a working version where documentation matched behaviour and consistently worked on all our machines and the cloud was our first big win! This came after tireless efforts at learning the language, the ecosystem, and the underlying technology while iteratively writing code.\\n\\nlibp2p also provides a way to allow peers to communicate even if they are behind private networks(or NAT routers). This makes it easy to deploy these nodes in different scenarios without the need to engineer the network or create exceptions. Implementing this behaviour proved to be a challenge as well when we started. With some help from the libp2p team and also removing some of the conflicting code helped us get better stability on this feature and release it as part of the prototype release.\\n\\n> From our first release we gained enough confidence to make this improvement and release another patch version right after - [NAT support on Pyrsia](https://github.com/pyrsia/pyrsia/releases/tag/v0.1.1).\\n\\n## A real decentralized network makes its first appearance\\n\\nWith a consistently working application we now had a `last known good solution` for making further improvements. Our next goal was to commission nodes in the cloud that have the authority(hence called Authority nodes) to be part of the blockchain consensus network.\\n\\n> We released a [decentralized network powered by a cloud node](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0) at the CDSummit at Kubecon + CloudNativeCon 2022.\\n\\nThis was our first version where the cloud service was always on. An always on service provided a really easy way to onboard and connect to the network. The `get started` experience greatly improved in this version, we were able to download docker images and also request docker images that previously did not exist on the network. Now the network was ready to be used by participants at the CDSummit and anyone else who liked to engage.\\n\\n> We were ready for the CD Foundation 2 nights before we went to CDSummit in Detroit.\\n\\n## Becoming part of the CD Foundation\\n\\nAlongside writing the code and developing software we were working with the CD Foundation. Numerous presentations and discussions helped us make the case for Pyrsia. Multiple interactions we had with the Technical Oversight Committee(TOC) and other smaller forums gave us confidence about our preparedness. By this time I had enough practice to be able to answer many of the questions or doubts people had about Pyrsia\'s goals and mission. We worked through the process of project submission and after a voting exercise we joined CD Foundation as an incubation project.\\n\\nAfter the vote there were still a number of steps to complete to make sure we legally and materially have the right permission structure to become a project that is easy to contribute and take forward.\\nOverall, I received great support from the Pyrsia team in making code/process changes as we went through transferring shared resources over to CD Foundation. Everytime I was stuck or needed support I was able to get quick help from the team at CD Foundation and Linux Foundation. After the transition to CD Foundation web resources we were able to continue with our usual team rituals like standups, retrospective meetings and community meetings without disruption and function without interruption.\\n\\n## Delivering frequently and regularly\\n\\nSince CD Summit in October we have a stable network, we have been able to up the cadence of our delivery cycles and deliver a new release every month. In case you missed it the following versions have been released since October 2022\\n\\n[v0.2.1 - MacOS service, request new artifacts, simpler configuration](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.1)\\n\\n[v0.2.2 - libp2p upgrade, rust toolchain, clap update for CLI](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.2)\\n\\nWe are getting into a process where for every release we are able to pick and prioritize our goals and measure our progress towards them during the 2 sprints that follow. We hope to continue this to be able to make small, incremental improvements on Pyrsia.\\n\\n## Looking into the next year\\n\\nOn the back of the December release we are getting ready to release v0.2.3 in January 2023. Following that we will continue making a dent in our technical debt and continue progressing towards our next major milestone of releasing Java support by version v0.3.0. Along the way we have a few other significant improvements lined up eg. a scalable build service, wider Authority node network that runs on multiple clouds, an API that will encourage integration with language and package ecosystems and so on.\\n\\nI can\'t wait to get started in 2023 and show off new features to our community.\\n\\nI am thankful to the community, the Linux Foundation, the CD Foundation and the many different communities we have now become part of. Without your support and criticism 2022 would not have been what it was for Pyrsia. Pyrsia started as an idea in 2022 but has grown into its own system over this year. Looking forward to growing it further with you together."},{"id":"/2022/12/20/pyrsia-0.2.2-released","metadata":{"permalink":"/blog/2022/12/20/pyrsia-0.2.2-released","source":"@site/blog/2022-12-20-pyrsia-0.2.2-released.md","title":"Release 0.2.2","description":"Announcing a new release","date":"2022-12-20T00:00:00.000Z","formattedDate":"December 20, 2022","tags":[{"label":"pyrsia","permalink":"/blog/tags/pyrsia"},{"label":"rust","permalink":"/blog/tags/rust"},{"label":"onboarding","permalink":"/blog/tags/onboarding"},{"label":"upgrade","permalink":"/blog/tags/upgrade"},{"label":"0.2.2","permalink":"/blog/tags/0-2-2"},{"label":"release","permalink":"/blog/tags/release"}],"readingTime":1.5,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Release 0.2.2","authors":"sudhindra","tags":["pyrsia","rust","onboarding","upgrade","0.2.2","release"]},"prevItem":{"title":"Pyrsia Anniversary Recap","permalink":"/blog/2022/12/30/pyrsia-anniversary-recap"},"nextItem":{"title":"How Pyrsia is Using libp2p to Take Over the World!","permalink":"/blog/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp"}},"content":"## Announcing a new release\\n\\nWe are happy to announce the release of [version 0.2.2](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.2) today!\\n\\nAs we continue to build Pyrsia we are now settling in on a regular release schedule. This is to allow us to release consistently and in small increments.\\n\\nStarting this release we are listing the important features we hope to cover in the upcoming release. They are listed as part of [the milestone definition](https://github.com/pyrsia/pyrsia/milestone/8).\\n\\nThis release added a few important upgrades:\\n\\n* Upgrade libp2p to 0.50.0\\n* Upgrade clap for Pyrsia CLI\\n* Upgrade and pin rust version to 1.64\\n* Ability to query a requested build\'s status\\n* Improvements in error messages\\n* Documentation fixes and improvements\\n* Onboarding resources for new developers hoping to learn about Pyrsia and Rust\\n\\nA big thing we learnt during this release is the ability to pin our builds to a definitive version of Rust. This simplifies our build and github processes significantly because we will be able to\\nfind the application rust version for every release. `Cargo.toml` will have that release defined and will be the one place to look for it for any automation.\\n\\nWhile processing the release and testing it we also found an inadvertent dependency being pulled in - openssl. This dependency broke deployments on linux. We were able to discover a fix to use rusttls instead. We discovered this while running github actions that relied on `ubuntu-latest` instead of the specific LTS version of `ubuntu` we expected. We have now pinned the version of ubuntu that Pyrsia builds with.\\n\\nOverall this will fix some of the issues that were reported to us and also make developer/contributor experience better.\\n\\nPlease [download our installers](https://pyrsia.io/docs/tutorials/quick-installation/), try out Pyrsia with Docker and [let us know](https://pyrsia.io/docs/community/get_involved/) if you are looking for something Pyrsia does not support yet."},{"id":"/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp","metadata":{"permalink":"/blog/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp","source":"@site/blog/2022-12-20-using-libp2p-to-take-over-the-world-2022-ipfs-camp.md","title":"How Pyrsia is Using libp2p to Take Over the World!","description":"IPFS Camp and Libp2p Day","date":"2022-12-20T00:00:00.000Z","formattedDate":"December 20, 2022","tags":[{"label":"rust","permalink":"/blog/tags/rust"},{"label":"libp2p","permalink":"/blog/tags/libp-2-p"},{"label":"ipfs","permalink":"/blog/tags/ipfs"},{"label":"ipfs-camp","permalink":"/blog/tags/ipfs-camp"},{"label":"pyrsia","permalink":"/blog/tags/pyrsia"}],"readingTime":3.435,"hasTruncateMarker":false,"authors":[{"name":"Elliott Frisch","title":"Pyrsia Contributor","imageURL":"https://github.com/efrisch.png","key":"efrisch"}],"frontMatter":{"title":"How Pyrsia is Using libp2p to Take Over the World!","authors":"efrisch","tags":["rust","libp2p","ipfs","ipfs-camp","pyrsia"]},"prevItem":{"title":"Release 0.2.2","permalink":"/blog/2022/12/20/pyrsia-0.2.2-released"},"nextItem":{"title":"Create macOS Installer for Rust Binary App","permalink":"/blog/2022/12/02/create-macOS-brew-installer-for-rust-binary"}},"content":"## IPFS Camp and Libp2p Day\\nHeading to [IPFS Camp 2022](https://2022.ipfs.camp/) (the 2022 theme is discovering how to use IPFS to build a better web) on Thursday October 27, my flight scheduled for 2:53 pm, racing through Atlanta I realized I forgot my coat half-way to the airport. No time to retrieve it, I found myself aboard United flight 1829 to Newark, NJ arriving at EWR about 2 and a half hours later (without a coat). I was waiting for my connecting flight to Lisbon when they announced a gate change. Walked with the others down to the new gate. In the air at 2035 we arrived at about 0820 Friday morning and made our way to Portuguese customs.\\n\\nIt is *already* time, I find a taxi outside the airport. Lucky the taxi drivers\' English is far superior to my Portuguese, it cost a mere 10 Euros for the ride to the Convento do Beato and Day 1 of IPFS Camp!\\n\\nAfter a full night of travel I was excited to get into the conference and get technical - however jet lagged.\\n\\n\\n## Day 1\\nDay 1 is a bit of a blur, as the IPFS Camp speakers regaled us with the latest happenings in IPFS. [JS-IPFS](https://js.ipfs.tech/), [IPVM](https://fission.codes/blog/ipfs-thing-breaking-down-ipvm/), [Iroh](https://iroh.computer/) (Rust implementation of IPFS) and Filecoin and NFTs; oh my! I attend the Keynotes, and then learn about plans to \u201cdecentralize all of the things!\u201d [Alternative IPFS implementations](https://youtu.be/HRYREdsLt5k), then the IPFS project expo where I was able to experiment with Fission\u2019s IPVM.\\n\\n### Iroh\\nThe [Iroh story](https://youtu.be/qPBR2K2X6cs) is compelling, because they have a complete IPFS implementation in Rust.\\n\\n### js-ipfs\\n[js-ipfs](https://youtu.be/pXOBE9tfevQ) is interesting, because they\u2019re capable of running in both node and the browser. Might try it in Rhino as well. But these days Rust is the language I use for my primary day to day development at work.\\n\\n### IPVM\\nThe [IPVM story](https://youtu.be/rzJWk1nlYvs) is also compelling, because they intend to host WASM VMs as potentially a new kind of \\"serverless\\" infrastructure. The ability to use distributed data as executable code in a decentralized cloud is fascinating technically.\\n\\nFeeling exhausted, and having been awake since Thursday, I took an Uber back to the hotel, checked-in, showered and slept. I note the shower is significantly raised and breakfast is served at 7 am.\\n\\n## Day 2\\n I breakfast and hop in an Uber and back to the Convento do Beato, where I attended talks on Web 3; especially memorable were [IPLD](https://ipld.io/), [WNFS](https://guide.fission.codes/developers/webnative/file-system-wnfs) and [Graphsync](https://github.com/myelnet/rs-graphsync).\\n\\n[IPLD is a data modeling language](https://youtu.be/J_Q6hF_lPiM). Used to model graph based data structures. Primary use case is for blockchain with-in filecoin.\\nWNFS is a file system built on top of IPFS. Offers pinning services. This sounds conceptually like what we\'re building.\\n[Graphsync](https://github.com/myelnet/rs-graphsync) is used by Filecoin for syncing the blockchain. Possibly a good fit for syncing blockchains. Requires IPLD.\\nThe measurement and performance unconference includes many interesting projects, especially [Testground](https://docs.testground.ai/).\\n\\n## Day 3\\nIt\'s libp2p day so I sit at the presenter\'s table and prepare for [my talk](https://youtu.be/aIxmQKWUjNY). Internet is spotty (it is a former convent) so I setup my phone as a Hotspot (my fellow presenters are especially grateful) and download the Docker image I intend to use for my talk (it works so much faster when you precache your data, but we really should use something heavier than Alpine); the audience appears to appreciate the demo working at all (as the Internet was not working in the convent at the time) and the demo impresses.\\n\\nAnswering questions, and interacting with others\' at libp2p day yields several insights into behaviors we are seeing in our p2p network. For example, we should be implementing [PING](https://docs.rs/libp2p/latest/libp2p/ping/index.html) as that provides a heartbeat mechanism and would allow our peers to timeout far more efficiently (currently can take 12 minutes).\\n\\nOnce again it is late, Uber to the hotel, eating and sleeping. \\n\\nSadly, now IPFS camp is over, but I am glad that I was able to be here and have these conversations and make great connections!\\n\\n![IPFS Camp 2022 Group Photo](/img/blog/2022-ipfs-camp-group.png \\"IPFS Camp 2022 Group Photo\\")\\n\\nPlease checkout [my talk](https://youtu.be/aIxmQKWUjNY) and the [slides](https://docs.google.com/presentation/d/1rn0NKAoTpxyA2iTPE_8fkEqKI3ke8xu9gnhcLyrm7Dk) to learn more about [Pyrsia](https://pyrsia.io/)."},{"id":"/2022/12/02/create-macOS-brew-installer-for-rust-binary","metadata":{"permalink":"/blog/2022/12/02/create-macOS-brew-installer-for-rust-binary","source":"@site/blog/2022-12-02-create-macOS-brew-installer-for-rust-binary.md","title":"Create macOS Installer for Rust Binary App","description":"Recently the Rust programming language has enjoyed the success and thrilled the many developers specially working on","date":"2022-12-02T00:00:00.000Z","formattedDate":"December 2, 2022","tags":[{"label":"rust","permalink":"/blog/tags/rust"},{"label":"macos","permalink":"/blog/tags/macos"},{"label":"installer","permalink":"/blog/tags/installer"},{"label":"homebrew","permalink":"/blog/tags/homebrew"},{"label":"brew","permalink":"/blog/tags/brew"}],"readingTime":7.015,"hasTruncateMarker":false,"authors":[{"name":"Manas Das","title":"Pyrsia Contributor","image_url":"https://github.com/dasmanas.png","imageURL":"https://github.com/dasmanas.png"}],"frontMatter":{"title":"Create macOS Installer for Rust Binary App","authors":[{"name":"Manas Das","title":"Pyrsia Contributor","image_url":"https://github.com/dasmanas.png","imageURL":"https://github.com/dasmanas.png"}],"tags":["rust","macos","installer","homebrew","brew"]},"prevItem":{"title":"How Pyrsia is Using libp2p to Take Over the World!","permalink":"/blog/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp"},"nextItem":{"title":"Release 0.2.1","permalink":"/blog/2022/11/30/pyrsia-0.2.1-released"}},"content":"Recently the Rust programming language has enjoyed the success and thrilled the many developers specially working on \\nSystem Level Software and building decentralized applications. When releasing your software, it is usually desirable to \\nprovide an easy to use installer for end users, ideally reducing the configuration burden on users and providing\\nindividual developers with control of how the application should function at the end users environment.\\n\\nThere are advantages of having installers for your binaries and a few are mentioned here. \\n\\n- User doesn\'t need to provide any configuration, environment variables or base directories for the binary to run on users\\nmachine. Rather software manufacturer packages those defaults with the installer.\\n- User can be alerted in the event of a new version release of the software.\\n- Developer can have more control on managing context of the app, providing backward compatibility, cleaning up storage \\nused by the app.\\n\\n\\n\\n## Build a small binary app in Rust & Create an Installer\\n\\nIn this sections we will build a small rust binary and an installer for macOS using [Homebrew](https://brew.sh/).\\n\\n### Sample code for the rust binary\\n\\nIn this example we will exercise a basic rust binary application to demonstrate how to build an installer. The rust program\\nwhich listens to a TCP Socket and write the text message on to listener\'s standard output (i.e. stdout) stream. The \\nprogram also has an option to set the port from an environment variable. Final goal is to run the software as a \\nbackground process and log the text to Listener\'s output stream whenever any other application sends message to the\\nsocket.\\n\\nLet\'s create a rust project named `rust_app` using `cargo new rust_app --bin`. It will create binary project structure\\nas below.\\n\\n```shell\\nsample_rust_app\\n\u251c\u2500\u2500 Cargo.lock\\n\u251c\u2500\u2500 Cargo.toml\\n\u2514\u2500\u2500 src\\n    \u2514\u2500\u2500 main.rs\\n```\\n\\nContent of Cargo.toml\\n\\n```toml\\n[package]\\nname = \\"rust_app\\"\\nversion = \\"0.1.0\\"\\nedition = \\"2021\\"\\n\\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\\n\\n[dependencies]\\n\\n```\\n\\nA very simple `main.rs` which listens on a port and writes the content into the STDOUT stream.\\n\\n```rust\\nuse std::env;\\nuse std::io;\\nuse std::io::{BufRead, Error};\\nuse std::net::{TcpListener, TcpStream};\\n\\nfn main() -> std::io::Result<()> {\\n  let port = env::var(\\"LISTEN_PORT\\").unwrap_or(String::from(\\"8080\\"));\\n  let listener = TcpListener::bind(format!(\\"127.0.0.1:{}\\", port))?;\\n  // accept connections and process them serially\\n  for stream in listener.incoming() {\\n    handle_client(stream?)?;\\n  }\\n  Ok(())\\n}\\n\\nfn handle_client(mut stream: TcpStream) -> Result<(), Error> {\\n  let mut reader = io::BufReader::new(&mut stream);\\n  let received: Vec<u8> = reader.fill_buf()?.to_vec();\\n  reader.consume(received.len());\\n  String::from_utf8(received)\\n          .map(|msg| println!(\\"{}\\", msg))\\n          .map_err(|_| {\\n            io::Error::new(\\n              io::ErrorKind::InvalidData,\\n              \\"Couldn\'t parse received string as utf8\\",\\n            )\\n          })\\n}\\n```\\n\\n### Build\\n\\nBuild the binary project using `cargo build --all-targets --workspace --release`. On successful build completion, binary\\nwill be placed under `target/release/` directory. Let\'s try the binary with a sample input.\\n\\nRun the binary while setting `LISTEN_PORT` to `9090` to accept messages on localhost 9090 TCP port.\\n\\n```shell\\n$ export LISTEN_PORT=9090\\n$ ./target/release/rust_app\\n```\\n\\nWe are going to use netcat client to send message to TCP socket like below.\\n\\n```shell\\n$ echo sample_text | nc localhost 9090\\n```\\n\\nNow check the rust_app program terminal. It will show the same text i.e. `sample_text` which we sent through netcat\\nclient.\\n\\n### Upload Archive in Cloud Storage\\n\\nNow we will concentrate how to build an installer for macOS. We choose Homebrew package manager. Homebrew requires a URL\\nto download your binary. There are a few choices to host your executable, like any cloud provider with file storage\\nservice or may be GitHub Releases. For the current use case, I am using GitHub Releases because it is free and easy to\\nuse.\\n\\nFrom the rust source code example, the binary is archived (using `tar -C target/release -czf rust_app.tar.gz rust_app`)\\nand uploaded into a GitHub release and is available under \\nhttps://github.com/dasmanas/homebrew-rust-app/releases/download/v0.0.1/rust_app.tar.gz link. We will require this link \\nin the installation instruction.\\n\\n### Homebrew to Create the macOS Installer\\n\\nHomebrew offers a way to install formula from third party repositories (i.e. Taps) like GitHub repositories instead of \\nhaving it as part of core homebrew formula [homebrew-core](https://github.com/Homebrew/homebrew-core). We will create \\none such GitHub project to host our formula. GitHub project name is `homebrew-rust-app` while following the naming \\nconvention `homebrew-<project_name>` to have better convenience for the user while tapping the repository.\\n\\nWe will create the homebrew project in following structure which will hold the Ruby formula file under Formula directory\\nlike shown here.\\n\\n```\\nhomebrew-rust-app\\n\u251c\u2500\u2500 Formula\\n\u2502   \u2514\u2500\u2500 listener.rb\\n\u2514\u2500\u2500 README.md\\n```\\n\\nThe Ruby file contains the installation instruction of your binary. Here is a sample ruby file for the formula. Here we\\nwill try to achieve a few things for our example.\\n- A macOS installer for the binary.\\n- User of the software doesn\'t need manage any configuration. Defaults (config, env vars etc.) will be manage as part of\\nthe installation.\\n- Install the software under a managed directory by Homebrew. This gives more control to the software manufacturer to\\nsupport backward compatibility or cleaning up memory in at times specially during software version update.\\n- An installer which can be run as background service.\\n- Sample test case for the installer which can be performed even before starting the installer as background service\\nwill provide a better determine if there is any potential issue.\\n\\n```ruby\\nclass Listener < Formula\\n  desc \\"A small description of your formula\\"\\n  # A home page URL for your software\\n  homepage \\"https://github.com/dasmanas/homebrew-rust-app/releases\\"\\n  # URL from where the installer archive is available\\n  url \\"https://github.com/dasmanas/homebrew-rust-app/releases/download/v0.0.1/rust_app.tar.gz\\"\\n  # Sha256 can be calculated using \\"shasum -a 256 <archive_name.tar.gz>\\"\\n  sha256 \\"c19c678e755d98506c372dd631640702ef2b7da225ffaee20453deb0c2b4a213\\"\\n  license \\"Apache-2.0\\"\\n  version \\"0.0.1\\"\\n\\n  def install\\n    ENV.deparallelize\\n    # Installing the app\\n    bin.install \\"rust_app\\"\\n  end\\n\\n  def post_install\\n    # Instruction to create a directory which may be used to manage file resources for the app. rust_app directory\\n    # will be created under /usr/local/var directory.\\n    (var/\\"rust_app\\").mkpath\\n  end\\n\\n  # Section to add different instruction for the user\\n  def caveats\\n    s = <<~EOS\\n      We\'ve installed your rust_app.\\n      To test rust_app installation:\\n        brew test listener\\n      To run rust_app Node as a background service:\\n        brew services start listener \\n      To check the service status:\\n        brew services list\\n      To stop rust_app Node background service:\\n        brew services stop listener\\n    EOS\\n    s\\n  end\\n\\n  service do\\n    def envvarhash\\n      return {PATH: std_service_path_env, LISTEN_PORT: \\"9090\\"}\\n    end\\n    run [opt_bin/\\"rust_app\\"]\\n    keep_alive true\\n    process_type :background\\n    environment_variables envvarhash\\n    log_path var/\\"rust_app/logs/stdout/rust_app.log\\"\\n    error_log_path var/\\"rust_app/logs/stdout/rust_app.log\\"\\n    working_dir var/\\"rust_app\\"\\n  end\\n\\n  test do\\n    (testpath/\\"rust_app\\").mkpath\\n    (testpath/\\"tmp\\").mkpath\\n    puts testpath\\n    child_pid = fork do\\n      puts \\"Child process initiated to run rust_app\\"\\n      puts \\"Child pid: #{Process.pid}, pgid: #{Process.getpgrp}\\"\\n      #setsid() creates a new session if the calling process is not a process group leader.\\n      Process.setsid\\n      puts \\"Child new pgid: #{Process.getpgrp}\\"\\n      puts \\"Initiating rust_app...\\"\\n      ENV.prepend \\"LISTEN_PORT\\", \\"9090\\"\\n      system \\"#{bin}/rust_app\\"\\n    end\\n    puts \\"Waiting for rust_app TCP socket listener to be up...\\"\\n    sleep 10\\n    begin\\n      system \\"echo sample_text | nc localhost 9090\\"\\n      assert_match \\"rust_app\\",\\n                   shell_output(\\"lsof -nP -i4TCP:9090 | grep LISTEN\\")\\n    rescue\\n      puts \\"test1\\"\\n      assert_raises(CustomError) do\\n        raise CustomError, \'This is really bad\'\\n      end\\n    ensure\\n      pgid = Process.getpgid(child_pid)\\n      puts \\"Sending HUP to group #{pgid}...\\"\\n      Process.kill(\'HUP\', -pgid)\\n      Process.detach(pgid)\\n      puts \\"Parent process exiting...\\"\\n    end\\n  end\\nend\\n```\\n\\nIn the ruby script, the section `service do ... end` takes care of registering the software as background service. The \\nblock of ruby script creates the required plist file under `~/Library/LaunchAgents/` for the Launch Agents. At the same \\ntime it eliminates the need of handcrafted plist file. For more information you can always refer to Homebrew\'s \\n[Service files](https://docs.brew.sh/Formula-Cookbook#service-files) official doc.\\n\\nWe also added a `test do ... end` section to the ruby script to demonstrate the test capability. User can run a test on\\nthe installer even before starting the same as a service. \\n\\n### How to install your software as service\\n\\nNow it is ready to release the installer. To use the installer in macOS, here are some important tips.\\n\\n- Tap the third party repository for the brew formula. E.g. `brew tap dasmanas/rust-app`.\\n- Install the formula from the tap. E.g. `brew tap listener`\\n- Test the installed binary. E.g. `brew test listener`\\n- Install the binary as service. E.g. `brew services start listener`. Once service has started as background process, \\nthe status of the service can be verified using `brew services list`.\\n- Background service can be stopped at any time using brew\'s services utility. E.g. `brew services stop listener`\\n\\nIn Pyrsia we built similar kind of installer for macOS. If you are a macOS user, you may also like to take a\\nlook at the code base from [homebrew-pyrsia](https://github.com/pyrsia/homebrew-pyrsia) or try out \\n[Quick Installation](/docs/tutorials/quick-installation) guide to install Pyrsia. For any improvement suggestion or to\\ncontribute open issue or pull request accordingly under [Pyrsia](https://github.com/pyrsia) project."},{"id":"/2022/11/30/pyrsia-0.2.1-released","metadata":{"permalink":"/blog/2022/11/30/pyrsia-0.2.1-released","source":"@site/blog/2022-11-30-pyrsia-0.2.1-released.md","title":"Release 0.2.1","description":"Announcing a new release","date":"2022-11-30T00:00:00.000Z","formattedDate":"November 30, 2022","tags":[{"label":"pyrsia","permalink":"/blog/tags/pyrsia"},{"label":"cli","permalink":"/blog/tags/cli"},{"label":"installer","permalink":"/blog/tags/installer"},{"label":"service","permalink":"/blog/tags/service"},{"label":"configuration","permalink":"/blog/tags/configuration"},{"label":"release","permalink":"/blog/tags/release"},{"label":"0.2.1","permalink":"/blog/tags/0-2-1"}],"readingTime":0.97,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Release 0.2.1","authors":"sudhindra","tags":["pyrsia","cli","installer","service","configuration","release","0.2.1"]},"prevItem":{"title":"Create macOS Installer for Rust Binary App","permalink":"/blog/2022/12/02/create-macOS-brew-installer-for-rust-binary"},"nextItem":{"title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","permalink":"/blog/2022/10/10/why-does-pyrsia-use-a-blockchain"}},"content":"## Announcing a new release\\n\\nWe are happy to announce the release of [version 0.2.1](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.1) today!\\n\\nThis release has incremental improvements over the [version 0.2.0](https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0) released at the CDSummit at Kubecon.\\n\\nOther than usual software quality improvements this release includes the following:\\n\\n* Better CLI experience - easy to configure\\n* MacOSX installer is able to start the service automatically - better experience for getting started.\\n* Automatically request builds on Pyrsia if an artifact does not exist on the network.\\n* Improved and updated documentation\\n\\n## Integration tests and Staging environment\\n\\nWe invested a lot of time in this release to improve our testing etiquette.\\n\\nWe now have a set of [integration tests](https://github.com/pyrsia/pyrsia-integration-tests) that we rely on to ensure that the network is stable and the functionality Pyrsia offers, continues to remain stable.\\n\\nWe did not have a dedicated infrastructure to test before going to production. As of this release we have a staging environment that allows us to test before we deploy to production.\\n\\nMore testing is better!\\n\\nPlease [download our installers](https://pyrsia.io/docs/tutorials/quick-installation/), try out Pyrsia with Docker and [let us know](https://pyrsia.io/docs/community/get_involved/) if you are looking for something Pyrsia does not support yet."},{"id":"/2022/10/10/why-does-pyrsia-use-a-blockchain","metadata":{"permalink":"/blog/2022/10/10/why-does-pyrsia-use-a-blockchain","source":"@site/blog/2022-10-10-why-does-pyrsia-use-a-blockchain.md","title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","description":"Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.","date":"2022-10-10T00:00:00.000Z","formattedDate":"October 10, 2022","tags":[{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"consensus","permalink":"/blog/tags/consensus"},{"label":"cryptocurrency","permalink":"/blog/tags/cryptocurrency"},{"label":"proof-of-work","permalink":"/blog/tags/proof-of-work"},{"label":"proof-of-stake","permalink":"/blog/tags/proof-of-stake"},{"label":"security","permalink":"/blog/tags/security"},{"label":"transparency","permalink":"/blog/tags/transparency"},{"label":"provenance","permalink":"/blog/tags/provenance"}],"readingTime":13.535,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","authors":"sudhindra","tags":["blockchain","consensus","cryptocurrency","proof-of-work","proof-of-stake","security","transparency","provenance"]},"prevItem":{"title":"Release 0.2.1","permalink":"/blog/2022/11/30/pyrsia-0.2.1-released"},"nextItem":{"title":"Why Pyrsia is being built in Rust?","permalink":"/blog/2022/09/30/why-pyrsia-is-being-built-in-rust"}},"content":"Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.\\n\\nBlockchain technology is deployed to leverage the following features:\\n\\n* Distributed ledger: Blockchain implementations use a distributed ledger and perform transactions based on consensus.\\n* Consensus based commits: Typically blockchain implementations come with an implementation of a Byzantine Fault Tolerance (BFT) * algorithm[1].\\n* Transparency and Immutability: Blockchain transactions are transparent and immutable, meaning they cannot be tampered with, thus * increasing trust and confidence in the system.\\n* Faster transactions: Third party verification is eliminated thus causing faster transactions.\\n* Improved security: Blockchain transactions embed security within them which can be verified by third parties. Any attempts at adding malicious data make the blockchain invalid thus exposing breaches.\\n\\nA software supply chain backed by a consistent verifiable ledger using blockchain brings trust into the open source software world. Also as blockchain commits are typically implemented based on BFT they provide security against failures in a distributed network. This provides protection against malicious network nodes committing data to the blockchain.\\n\\nIn this blog we discuss how Pyrsia is a tool for securing your software supply chain. We discuss the application of blockchain technology to provide an immutable record of each open source software being built into a binary. We further discuss how other aspects of blockchain technology help us build a distributed system that can scale across the globe.\\n\\n## Software Supply Chain Security\\n\\nSoftware supply chain has received much attention since a few well known events have affected the software industry and these have also percolated into real lives of people (eg. Equifax data breach[2], Solarwinds breach[3], Log4Shell vulnerability[4], Spring4Shell vulnerability[5] and many more).\\nSoftware supply chain has become a core topic of discussion within the software industry and also caused policy decisions[6] to solidify the security posture across the board.\\n\\nThe vulnerabilities discussed above and many more that go without receiving so much attention are discovered in the open source libraries that become part of the end user software. Much of this open source software development relies on few people\u2019s effort and on tools that do not give insight into how the said software is being built. Establishing any level of trust becomes a challenge. Furthermore, once this open source software becomes part of the supply chain, we rely on a lot of manual effort to determine the components that are part of the software supply chain.\\n\\n>\\n> Our proposal for Pyrsia [7], a decentralized package network, aims to provide a solution for a key part of the supply chain.\\n> Pyrsia aims to\\n>\\n> * Build trust for the open-source packages being used as dependencies in software development through certified and peer-verified builds\\n> * Provide a decentralized package network that understands package coordinates, semantics, and discoverability, and which continues to work even though there are local outages\\n>\\n\\nPyrsia aims to provide a tool to establish and verify trust in the software delivery world. With Pyrsia we hope to provide a source of information that can be used to automate much of this effort. 75% software comes from open source components[8] and with Pyrsia as the mechanism to manage these components we look towards a future where software is liquid[9].\\n\\nPyrsia aims to provide trustworthy provenance data which can be used to automate releases, patches and audit activities for the supply chain. Gathering all this information and sharing it with decentralized nodes requires a lightweight and tamperproof database.\\n\\nIn order to make Pyrsia\u2019s goals successful we need to use a database that can serve the following requirements:\\n\\n* Performant in a distributed setting\\n* Tamperproof\\n* Lightweight enough to be able to stream updates efficiently\\n\\nA blockchain implementation is a perfect fit since it provides all the above features and provides the ability to add verification mechanisms on top of it. Let\u2019s talk a little bit more about the current state of the software supply chain.\\n\\n## State of Software Supply chain\\n\\n### Lack of trustworthy provenance data\\n\\nAs it stands today we implicitly rely and trust the central repositories to provide updates to open source libraries. But evidence has shown that such implicit trust is not sufficient to secure the supply chain. There have been instances that show how this trust can be breached either by a rogue agent taking over control from the rightful owner (email squatting, typosquatting 1, typosquatting 2) or even the rightful owner turning rogue for some reason or getting burnt out.\\n\\nOverall building a definitive SBOM for your software continues to be a challenge. Querying to determine versions, related vulnerabilities, dependency chains and potential remediation still remains a manual process. Such manual processes are error prone and require investment of effort similar to that of building original software and thus do not get enough attention until disaster has struck.\\n\\nPyrsia started with a goal of building such a provenance log which is easy to use with automation, and scales across a distributed network.\\n\\nPyrsia aims to keep the nodes on the network up to date using a peer to peer update mechanism. This is critical so that many of the Pyrsia functions can be performed on the peer node without having to traverse. the network. The critical part here that needs to be upto date is the provenance log which is powered by the blockchain.\\n\\nThis provenance log will further support an automation infrastructure to aid software delivery decisions which currently requires manual intervention.\\n\\n### Dependence on centralized repositories\\n\\nRealizing that centralized repositories have run their course in terms of being a source of trust and reliability, we started the Pyrsia design with emphasis on being distributed by design.\\nWe need a distributed network since centralized repositories lack the reliability and scale that decentralized systems can provide.\\n\\nPyrsia relies on the peer-to-peer (P2P) communication mechanisms (think bittorrent) to exchange artifacts, metadata about those artifacts and also the provenance log. Pyrsia leverages two different channels to make these network transfers efficient. One channel delivers artifacts and another channel is used to synchronize the blockchain over the network. Artifacts are delivered on demand but the provenance log is updated frequently and this information needs to be lightweight - which is facilitated by the append-only blockchain. Leveraging the P2P technology makes Pyrsia resilient to internet failure modes (data center failures or network failures) and allows the network to scale organically - even across geographical boundaries where data center availability may be a challenge.\\n\\nBut using this technology also meant that Pyrsia could not rely on traditional data distribution mechanisms (like distributed databases, network caches, CDNs etc). Pyrsia needed a distributed database that was easy to update and transmit (read: serialize) over the network. Since P2P networks are also fault tolerant we needed to ensure that such a database can be usable from the local Pyrsia node (think git).\\n\\nGiven these constraints/requirements we started thinking about using a blockchain as a possible solution.\\n\\n### Trustworthy means tamperproof\\n\\nThe main feature that Pyrsia provides is a reliable and verifiable log for asserting your dependencies. This means that we need a log that is append only, written once and read many times and its entries to be immutable. We need a database that is tamper proof with guarantees of discovering and resolving any malicious additions. Blockchain technology has proved to be one of those immutable databases.\\n\\nHence we chose a Blockchain technology that acts as an immutable ledger for the purpose of storing all data related to artifacts. Furthermore as we mentioned before  Blockchain implementation requires a consensus mechanism based on BFT to ensure that there is security against taking over the network. An implementation of Blockchain implements BFT to ensure there is consensus for each block of data committed. BFT algorithms are resilient against network attacks that span the network and can tolerate upto \u2153 of the network failures. For a reasonable sized network getting control of \u2153 of the network nodes is a costly operation for hackers.\\n\\n## Pyrsia Design\\n\\n### Provenance Log\\n\\nPyrsia is built to provide a Provenance log to provide enough information about open source software. This information can be used to build decision making automation to enable releases and control what can be released. This provenance log is built to be lightweight so that a large number of software binaries can be tracked efficiently. In order to store such a provenance log we need a storage solution that has auditable and verifiable links that connect to history. Blockchain or immutable ledgers provide an efficient mechanism to store such chains of information and allow for quick retrieval.\\n\\nAnother feature Pyrsia is building is a search engine that can provide provenance log for each version, each binary type and each binary name. Pyrsia needs to parse this information quickly so that search indexes remain current at all times..Compared to the heavy footprint of the artifacts themselves the blockchain is much more lightweight and intends to keep itself that way. As the ecosystem grows this database will grow in size but still remain magnitudes smaller than the artifact storage.\\n\\n### Network Structure\\n\\nPyrsia\u2019s design contains a network structure that provides direct connectivity between peers thus allowing for immense scale. Having said that, given the emphasis on security we have a differentiation between nodes that run in the cloud and the ones that are run on individual/volunteer nodes. The nodes that run on the cloud have the ability to act as a large cache, have better network throughput thus providing a bigger conduit to reach the repositories. The volunteer nodes provide a P2P network, a sort of proxy cache to content and an effective distribution mechanism. The authority nodes are the only ones that can commit to the ledger and thus provide a trustworthy provenance log.\\n\\n![Pyrsia Network Design](/img/blog/provenance_log_architecture.png \\"Pyrsia Network\\")\\n\\nAlong with this the nodes on the cloud are deployed and maintained by Pyrsia governing organizations (Governing organizations are listed on <https://pyrsia.io/>). Having these owned by organizations instead of individuals enhances the availability of these nodes as well as vastly improves the security posture. We are now able to verify these nodes, provide identity mechanisms to have a provable chain of authority and provide membership privileges to keep the network secure - while scaling it across regions.\\n\\nThis network structure allows us another luxury, that of ensuring we control the data that is being committed to the blockchain. Early on we decided that Pyrsia will only allow the cloud nodes to commit to the blockchain using a consensus mechanism. This consensus mechanism will only allow authorized cloud nodes to commit and thus reduce the complexity of the consensus mechanism. Another aspect we realized is that, given Pyrsia will have very limited participants being able to commit to the blockchain we can stay away from the expensive, mining heavy, at times quite wasteful algorithms. Thus we steered clear from investing into the Proof of Work, Proof of Stake and similar algorithms. We have been focusing on using the Proof of Authority which has significantly reduced the complexity while providing us with sufficient control to keep the network secure.\\n\\nIn this design the authority is assigned and cannot be obtained through the means that are used on the open networks. Pyrsia governance organizations approve every node that has the authority to commit to the blockchain. This furthers our goal of providing a trustworthy network which has more control over what is available on the network. The Authority nodes are the only ones committing to the blockchain and then transmitting those updates to the peer nodes.\\n\\n## Leveraging the Blockchain technology\\n\\nGiven the above criteria and constraints and evidence of success of the blockchain technology we found that the right fit for Pyrsia\u2019s provenance log - which is its source of truth - using an implementation of blockchain technology was the right choice for Pyrsia.\\n\\nWe further assessed available implementations of blockchain and narrowed our choice of implementation based on the following criteria:\\nAvailability of multiple language support - especially good documentation for a Rust implementation\\nAbility to turn of or not have the concept of Currency to make transactions on the network\\nAbility to choose the consensus algorithms that fit Pyrsia\u2019s need and situation - Proof of Authority\\n\\nWe found that AlephBFT supported all these criteria and was easy to get started. We have been able to also build on top of AlephBFT to constrain the use cases of Pyrsia without giving away security. AlephBFT has also allowed us to configure the network nodes in a way that allows us the control we need to support the security.\\n\\n## Blockchain does not mean Crypto\\n\\nOne thing we have learnt over the course of this effort is that - whenever we talk about blockchain as the technology we use in Pyrsia, we have received critical feedback about how we are overcomplicating our design. When we reflected on this feedback we realized that the majority of it is due to the prevalent use of blockchain within the cryptocurrency world.\\n\\nBlockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it automatically gets associated with cryptocurrency and mining. And we have found that it is really hard to break this association. We also found that the most popular implementations connect the mining and crypto aspects to the blockchain in such a way that they become inseparable.\\n\\nBlockchain will act as the immutable ledger giving us the tamper proof database we need, with the ability to search it efficiently and distribute it across the peers as we need.\\n\\nPyrsia is open source and free. The key to ensuring that the open source community continues to engage and use Pyrsia is that there should not be any currency attached with actions on Pyrsia. From the get go this has been our main objective to keep this network free and open to use for the community and we have worked to implement an immutable ledger which does not have the concept of cryptocurrency in it. Our implementation has removed the requirement of requiring gas (a fuel to power your transactions on the blockchain) or currency for participation. Given the security concerns Pyrsia operates on a small number of Pyrsia nodes that participate in consensus. Running the Proof of Authority algorithm from certified nodes and limiting those number of nodes to the participants of the governing board, allows Pyrsia to maintain security without being open to any mining on the network. Pyrsia will also benefit from the lightweight implementation of AlephBFT so that we can scale across regions and keep the network always up to date.\\n\\nPyrsia aims to leverage blockchain to power the provenance data while not allowing any usage of cryptocurrency on the network. We believe that open source should be free to use and should not have incentives attached to it to allow for fairness. Pyrsia builds on the success of blockchain while saving resources (energy) by not allowing any competitive currency exchange on the network.\\n\\n## In Summary\\n\\nPyrsia leverages blockchain as an immutable ledger to provide a scalable provenance log. Blockchain technology is best suited for distributed large amounts of chained data across wide networks which is evidenced from the success of blockchain in the cryptocurrencies. Pyrsia is using this same technology to improve the state of the software supply chain by providing transparency into how open source software is being built on this network. This transparency is aimed to give you the confidence to use the open source library in your production environments.\\n\\n### References\\n\\n* [Byzantine Fault Tolerance](https://decrypt.co/resources/byzantine-fault-tolerance-what-is-it-explained)\\n* [Equifax data breach](https://www.synopsys.com/blogs/software-security/equifax-apache-struts-vulnerability-cve-2017-5638/)\\n* [Solarwinds breach](https://www.businessinsider.in/tech/news/heres-a-simple-explanation-of-how-the-massive-solarwinds-hack-happened-and-why-its-such-a-big-deal/articleshow/79945993.cms)\\n* [Log4Shell vulnerability](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)\\n* [Spring4Shell vulnerability](https://jfrog.com/blog/springshell-zero-day-vulnerability-all-you-need-to-know/)\\n* [Executive order on improving nations cybersecurity](https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/)\\n* [Pyrsia Proposal](https://pyrsia.io)\\n* [75% software comes from open source components](https://www.synopsys.com/software-integrity/resources/analyst-reports/open-source-security-risk-analysis.html?intcmp=sig-blog-rsa22)\\n* [Software is Liquid](https://jfrog.com/whitepaper/a-vision-of-liquid-software/)"},{"id":"/2022/09/30/why-pyrsia-is-being-built-in-rust","metadata":{"permalink":"/blog/2022/09/30/why-pyrsia-is-being-built-in-rust","source":"@site/blog/2022-09-30-why-pyrsia-is-being-built-in-rust.md","title":"Why Pyrsia is being built in Rust?","description":"When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.","date":"2022-09-30T00:00:00.000Z","formattedDate":"September 30, 2022","tags":[{"label":"rustlang","permalink":"/blog/tags/rustlang"},{"label":"rust","permalink":"/blog/tags/rust"},{"label":"security","permalink":"/blog/tags/security"},{"label":"web3","permalink":"/blog/tags/web-3"},{"label":"modern","permalink":"/blog/tags/modern"},{"label":"safety","permalink":"/blog/tags/safety"},{"label":"community","permalink":"/blog/tags/community"},{"label":"ecosystem","permalink":"/blog/tags/ecosystem"}],"readingTime":5.51,"hasTruncateMarker":false,"authors":[{"name":"Sudhindra Rao","title":"Pyrsia Maintainer","url":"https://github.com/betarelease","imageURL":"https://github.com/betarelease.png","key":"sudhindra"}],"frontMatter":{"title":"Why Pyrsia is being built in Rust?","authors":"sudhindra","tags":["rustlang","rust","security","web3","modern","safety","community","ecosystem"]},"prevItem":{"title":"Why does Pyrsia use a Blockchain(and no CryptoCurrency)?","permalink":"/blog/2022/10/10/why-does-pyrsia-use-a-blockchain"},"nextItem":{"title":"Peer Metrics in the Pyrsia Network","permalink":"/blog/2022/06/03/peer-metrics"}},"content":"When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.\\n\\n## Securing Open Source Software\\n\\nOpen source software is built mostly by people passionate about solving a problem and sharing their solutions widely. One of the differences in how we build proprietary software vs open source is that we find that many of those original developers do their best in keeping the software upto date and try to patch vulnerabilities as soon as they can. Although their efforts are usually the best they can do. In some well publicized cases, developers have experienced burnout and lack of interest in supporting what they built, due to resource constraints.\\n\\nFor proprietary software, there are well published processes and patterns which are used to build software and record how it was done. Open Source software usually does not get this rigor and often is found vulnerable.\\n\\nOn Pyrsia we focus on this missing piece of building open source software and are building a platform that offers build from source service while providing a record of how it was done. Pyrsia leverages a peer-to-peer distribution model for these binaries thus making the network resilient to failures.\\n\\n### Secure Software needs a secure platform\\n\\nWhile the aim of Pyrsia is to secure the software that it builds, a lot of trust/community involvement expects the network itself to be secure. Pyrsia as a platform has taken this expectation seriously and from the initial days invested a lot of energy into building it right.\\n\\nA few other considerations that were made during the initial discussions of Pyrsia include:\\n\\n* Decentralized network (think Web3) to leverage distribution of binaries across regions\\n* Build from source using independent randomly chosen nodes to ensure security by reducing surface of attack\\n* Consensus mechanism to ensure that multiple nodes participate in the build and verification process\\n* Deploying Pyrsia node instances on wide variety of architectures, operating systems, as well as footprints(think Intel Xeon all the way to Raspberry * Pi and beyond)\\n* Ensuring wide deployments have a minimal footprint - for transportation, but more importantly to further reduce the possibility of attacks\\n* Modern software that allows system programming - to enhance experience and also to restrict how the data structures can be used. Constraining how the software is built is key to making it more secure.\\n\\n## Choosing a programming language\\n\\nFor Pyrsia to address the above considerations we weighed them against a few popular languages with decent community voice and size.\\n\\nSpecifically we were looking for the following in a programming language ecosystem:\\n\\n* Welcoming community - People come first\\n* Modern language constructs that help us focus on the problem instead of the language\\n* Secure or easily to build for security\\n* Multiple OS and Arch support\\n* Ability to drop down to lower level to help implement any cryptography, improve performance\\n* Support for web3 implementations like p2p networking, blockchain, cryptography\\n* Installed base of system software in the language\\n\\n[Rust](http://rustlang.org) seemed to satisfy all these requirements, in fact with flying colors.\\n\\n## RUST Language\\n\\n### Rust philosophy [1]\\n\\n> Today we are very proud to announce the 1.0 release of Rust, a new programming language aiming to make it easier to build reliable, efficient systems. Rust combines low-level control over performance with high-level convenience and safety guarantees. Better yet, it achieves these goals without requiring a garbage collector or runtime, making it possible to use Rust libraries as a \\"drop-in replacement\\" for C.\\n\\nWhat makes Rust different from other languages is its type system, which represents a refinement and codification of \\"best practices\\" that have been hammered out by generations of C and C++ programmers. As such, Rust has something to offer for both experienced systems programmers and newcomers alike: experienced programmers will find they save time they would have spent debugging, whereas newcomers can write low-level code without worrying about minor mistakes leading to mysterious crashes.\\n\\n### History of Rust [2]\\n\\n> Rust began as a side project of Graydon Hoare, an employee at Mozilla. In short order, Mozilla saw the potential of the new language and began sponsoring it, before revealing it to the world in 2010.\\nOne possible source of the name, according to Hoare, is the rust fungus. This has caused Rust programmers to adopt \u201cRustaceans\u201d as their moniker of choice.\\n>\\n> Despite its relative youth, Rust has steadily risen in the ranks of popular programming languages. In fact, while it ranked 33 in July 2019, by July 2020 it had risen to the 18th spot on the [TIOBE Programming Community Index](<https://www.tiobe.com/tiobe-index/>). Similarly, according to [Stack Overflow Developer Survey](https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved), Rust has been the `most loved` language since 2016.\\n\\n### Rust language ecosystem\\n\\nThe above philosophy made Rust a great candidate for use in security solutions like Pyrsia. Some other aspects that sealed the deal as a programming language for us were:\\n\\n* Performance close to equivalent C level programs [3]\\n* Concurrent programming without the garbage collection [4]\\n* Rust has a borrow checker which ensures references do not outlive the data\\n* Rust can be compiled to reduced instruction set architectures\\n\\nAlong with the above, we also found that the initial set of libraries(libp2p, AlephBFT) we were looking to support, had mature implementations in rust. Also we found that the communities that supported these libraries were welcoming all implementers and learners alike. This openness within the Rust community in general made the choice easier for us.\\nA lot of these appealing features of the Rust ecosystem are well summarized in [5].\\n\\n## Summary\\n\\nWhen we set out to change how open source software is secured we had a choice to make - the language to build the security solution with. When we surveyed what was available there were multiple options. C due to its performance, Golang because of its mature installations in the wild, Rust as an up and coming community with performance and modern language features.\\n\\nIn the end it was clear to us that Rust was the right choice to make and we have started building Pyrsia in Rust. We realize that we have a steep learning curve and we are learning as a group. Come join us on our [Slack channel](https://cdeliveryfdn.slack.com/join/shared_invite/zt-1eryue9cw-9YpgrfIfsTcDS~hGHchURg) to discuss more.\\n\\n### References\\n\\n* [Rust Philosophy](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html)\\n* [Rust History](https://www.talentopia.com/news/the-rust-programming-language-its-history-and-why/)\\n* [Rust vs C](https://codilime.com/blog/rust-vs-c-safety-and-performance-in-low-level-network-programming/)\\n* [Garbage collection issues](https://discord.com/blog/why-discord-is-switching-from-go-to-rust)\\n* [Why projects use Rust?](https://codilime.com/blog/why-is-rust-programming-language-so-popular/#:~:text=High%20performance%20and%20safety%20are,amounts%20of%20data%20very%20quickly)"},{"id":"/2022/06/03/peer-metrics","metadata":{"permalink":"/blog/2022/06/03/peer-metrics","source":"@site/blog/2022-06-03-peer-metrics.md","title":"Peer Metrics in the Pyrsia Network","description":"Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and \\"fast\\". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.","date":"2022-06-03T00:00:00.000Z","formattedDate":"June 3, 2022","tags":[{"label":"p2p","permalink":"/blog/tags/p-2-p"},{"label":"peer-metrics","permalink":"/blog/tags/peer-metrics"}],"readingTime":4.145,"hasTruncateMarker":false,"authors":[{"name":"Mark Seaborn","title":"Pyrsia Contributor","image_url":"https://github.com/mseabornIBM.png","imageURL":"https://github.com/mseabornIBM.png"}],"frontMatter":{"title":"Peer Metrics in the Pyrsia Network","authors":[{"name":"Mark Seaborn","title":"Pyrsia Contributor","image_url":"https://github.com/mseabornIBM.png","imageURL":"https://github.com/mseabornIBM.png"}],"tags":["p2p","peer-metrics"]},"prevItem":{"title":"Why Pyrsia is being built in Rust?","permalink":"/blog/2022/09/30/why-pyrsia-is-being-built-in-rust"},"nextItem":{"title":"Blockchain Consensus","permalink":"/blog/2022/01/28/blockchain-consensus"}},"content":"Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and \\"fast\\". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.\\n\\nHerein I present the mechanism the Pyrsia team has created to help improve the selection process for downloading software distributions from peers. The idea is to improve upon the Kademila peer selection process and make \\"smarter\\" choices from Pyrsia peers based on a \\"peer metric\\". The mechanism is layered atop the Kademila peer selection process, which in Pyrisa returns a list of peers known to be in possession of an open-source distribution of interest. The peer metric is a real time assessment of the work-load of any given machine in the network, both related and unrelated to any current software transfers within the Pyrsia network.\\n\\nThe following table defines terms used in this blog.\\n\\n|Term|Definition|\\n|---|---|\\n|Requester|In this context a requestor is a Pyrsia client requesting a file to be downloaded or uploaded to/from its peer(s).|\\n|Peer (Pyrsia Peer)|Any Pyrsia client that is participating in the network.|\\n|Neighboring Node|Any node that is returned by the Kademila algorithm as having a software distribution desired by a peer.|\\n\\nAs previously stated, a primary goal of the peer-to-peer software distribution sharing function of Pyrsia is that it efficiently uses peers. The efficient use of peers can be broken down into two aspects, efficiencies related to uploading software distributions to peers and efficiencies related to downloading software distributions from peers. This post limits the discussion to downloading software distributions from peers.\\n\\nThe primary rule defined by our selection process is that requesters must not overwhelm peers by requesting too many software distributions too often from any one neighboring node. Though hard resource usage limits are a configuration function for Pyrsia Peers, Pyrsia\u2019s peer selection mechanism should also attempt to balance requests across the network of peers. Additionally, the peer selection mechanism should operate such that file requesters are not starved for bandwidth in the network by unresponsive peers, preventing fast downloads. While the first efficiency could be guaranteed by Pyrsia policy, the second one is more nebulous because Pyrsia cannot guarantee enough stable network peers exist at request times to achieve \u201cfast downloads\u201d.\\n\\nThe terms \u201cfast downloads\u201d and \u201crequesting too much data\u201d must be further defined to quantify what is meant. The means of describing these terms can be defined as a function of the attributes within the environment. There are measurable attributes of both the network and the Pyrsia peers participating in the networks that can help us define metrics to balance requests. These metrics will ultimately determine the quality of peers in the requesters\' peer list. The term quality in this context is related to the ability of a peer to satisfy a request for download and will be defined by the function Q(x):\\n\\n![$Q(x) = \\\\sum_{n=1} ^{pa\\\\ count} pa_n * weight](https://latex.codecogs.com/svg.image?Q(x)&space;=&space;\\\\sum_{n=1}&space;^{pa\\\\&space;count}&space;pa_n&space;*&space;weight)\\n\\nwhere `pa` is a peer attribute of the environment and `weight` is a number that determines the expense of the attribute. The quality number will be calculated on demand by peers returned in the list of peers generated by the Kadimela algorithm. The quality function can be used for either upload quality or download quality depending on the need. The metric is currently used during the selection process for downloading software distributions. Finally, we need to define what characteristics are important to drive analytics for decisions about transactions on the network. The following table lists the attribute used by to Pyrsia generate the peer metric in Pyrsia. The peer with the lowest number is considered to be the ideal candidate for the software distribution download.\\n\\n|Peer Attribute|Definition|\\n|---|---|\\n|Peer Network Load|A measurement of the current network bandwidth usage in terms packets in and packet out summed over all network interfaces.|\\n|CPU Load|The average CPU load over the last minute|\\n|Disk I/O Load|A measure of the current packets being read and written summed over all current processes on the system|\\n\\nThis system of measuring the quality of peers will evolved over time and as other attributes are defined, they will be integrated into the Pyrsia network."},{"id":"/2022/01/28/blockchain-consensus","metadata":{"permalink":"/blog/2022/01/28/blockchain-consensus","source":"@site/blog/2022-01-28-blockchain-consensus.md","title":"Blockchain Consensus","description":"Blockchain technologies are trending. There\u2019s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.","date":"2022-01-28T00:00:00.000Z","formattedDate":"January 28, 2022","tags":[{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"consensus","permalink":"/blog/tags/consensus"},{"label":"bitcoin","permalink":"/blog/tags/bitcoin"},{"label":"ethereum","permalink":"/blog/tags/ethereum"},{"label":"proof-of-work","permalink":"/blog/tags/proof-of-work"},{"label":"proof-of-stake","permalink":"/blog/tags/proof-of-stake"}],"readingTime":6.55,"hasTruncateMarker":false,"authors":[{"name":"Christopher McArthur","title":"Pyrsia Contributor","image_url":"https://github.com/prince-chrismc.png","imageURL":"https://github.com/prince-chrismc.png"}],"frontMatter":{"title":"Blockchain Consensus","authors":[{"name":"Christopher McArthur","title":"Pyrsia Contributor","image_url":"https://github.com/prince-chrismc.png","imageURL":"https://github.com/prince-chrismc.png"}],"tags":["blockchain","consensus","bitcoin","ethereum","proof-of-work","proof-of-stake"]},"prevItem":{"title":"Peer Metrics in the Pyrsia Network","permalink":"/blog/2022/06/03/peer-metrics"}},"content":"Blockchain technologies are trending. There\u2019s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.\\n\\n## What is a Blockchain\\n\\nIBM has one of my [favorite definitions](https://www.ibm.com/topics/what-is-blockchain):\\n\\n>\xa0Blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets \\\\[... on] a network.\\n> An asset can be tangible (a house, car, cash, land) or intangible (intellectual property, patents, copyrights, branding). Virtually\\n> anything of value can be tracked \\\\[... ] on a blockchain network, reducing risk \\\\[...] for all involved.\\n\\nThere\u2019s a few key items to highlight from this definition are:\\n\\n- A shared, immutable ledger\\n- Recording and tracking assets\\n\\nSimply put, a Blockchain is a list of changes to assets, called transactions, which are grouped in blocks that are recognized by all participants in the network.\\n\\nUnfortunately, it leaves out one major element. How do blockchain networks reduce risk? How do blockchain networks agree on the shared ledger?\\n\\n## Consensus\\n\\nIn the world of blockchain, consensus is the agreement of which block is next. Collectively all the participants in the blockchain\u2019s network\\nshould come to the same conclusion.\\n\\nYou\u2019ve probably heard of \u201cProof of Work\u201d, usually called mining, and \u201cProof of Stake\u201d, these two are the most popular in terms of market share\\nin the crypto markets.\\n\\nThese consensus algorithms were some of the first to be popularized by projects like Bitcoin and Ethereum. These are far from the only ones, Proof of Authority, Proof of Burn, Proof of Capacity and Proof of History are just from others mentioned on [Investopedia\'s Website](https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp).\\n\\nLet\u2019s dive deeper into the two popular algorithms to see how they obtain consensus.\\n\\n### Proof of Work\\n\\nProof of Work is based on a mathematical expression which is very costly to compute a magic number, called a nonce, but easily verified. Each participant, typically referred to as a miner, begins the calculation with the transitions it\u2019s heard on the network since the last published block. Participants race each other to find the right answer and the winner traditionally gets a reward. It\u2019s difficult to cheat and very rewarding to operate in good faith.\\n\\nAt the time of writing, January 28th 2022, the reward is 6.25 BTC which is worth 236,755 USD. It\u2019s easy to draw parallels to the 1849 Gold Rush.\\n\\n![BitCoin Value](https://lh4.googleusercontent.com/lbGxZlJRF5GlNLNmbQlnS7Rdk0CHU9w2QjyfghfFLKWOa-bz7ZaEq83AWwVwEd4oJXZgUhyBQxzZ_-_6ytuISeQXU1er77nfwYpdoPgaE_8bvQqKFdsLmUVRbuc9NrePRDTtcZ7YbkqgTq5RMg)\\n\\nWhen miners hear of a new block, they immediately stop their calculation and begin listening for more transactions. This is approximately a 10 minute window for Bitcoin.\\n\\nWith a small number of competitors it\u2019s pretty straightforward but when tens of thousands of nodes are involved, what happens if two miners finish at the same time. Who wins?\\n\\n### Proof of Stake\\n\\nProof of Stake is an investment strategy where committing more capital means you\u2019re more likely to get the reward. [Peercoin](https://www.peercoin.net/whitepapers/peercoin-paper.pdf), a very early PoS implementation, kept the mining of PoW but required less computational complexity the more _coinage_ was staked. If two participants offer the same investment in the next block, which one is rewarded?\\n\\nIf someone is able to offer more capital for their block to be accepted, are they able to always win? Yes, this is a special type of security exploit called a 51% attack. If the confirmation of the next block is tied to a resource, then an entity which holds a majority stake can take control of the blockchain. Proof of Work is also susceptible to this type of attack.\\n\\n### Stale and Orphan Blocks\\n\\nMost blockchain\u2019s are actually trees, not linked lists which is what probably comes to mind for young data scientists. This probably comes as a shock but it\u2019s the secret ingredient to solving our racing condition when two participants propose the next block in PoW.\\n\\n> If two nodes broadcast different versions of the next block simultaneously, some\\n> nodes may receive one or the other first. In that case, they work on the first one they received,\\n> but save the other branch in case it becomes longer.\\n> The tie will be broken when the next proof-of-work is found and one branch becomes longer.\\n\\n[_Bitcoin: A Peer-to-Peer Electronic Cash System Section 5_](https://bitcoin.org/bitcoin.pdf)\\n\\nChains are made of links that connect to others. This data structure is referred to as a linked list, when a link\\npoints to both it\u2019s parent and child is a doubly linked list. Three sequential blocks being published would make the following chain:\\n\\n```mermaid\\nstateDiagram-v2\\n    [*] --\x3e Block_1\\n    Block_1 --\x3e Block_2 : Parent\\n    Block_2 --\x3e Block_3 : Child\\n    Block_3 --\x3e [*]\\n```\\n\\nIf block 4 was published at the same time as our block 3 a node would have the following tree:\\n\\n```mermaid\\nstateDiagram-v2\\n    [*] --\x3e Block_1\\n    Block_1 --\x3e Block_2 : Parent\\n    Block_2 --\x3e Block_3 : Child\\n    state Block_2 <<fork>>\\n        Block_2 --\x3e Block_4 : Nephew\\n        Block_3 --\x3e Block_5\\n    Block_5 --\x3e [*]\\n```\\n\\nSince it\u2019s extremely unlikely that a second pair of blocks would also be published at the same time, the tie is broken when the next sequential block is published. This is block 5 in the diagram above.\\n\\n#### Which branch should we follow\\n\\nWell, intuitively the \u201cstrongest\u201d branch of our tree is the one we should stick with. The strength comes from the amount of work that has gone into making the branch. More work means it\u2019s less likely that someone has cheated or lied.\\n\\n### Dynamic Validator Sets\\n\\n[Ethereum\u2019s new PoS system named _Consensus Layer_](https://ethereum.org/en/upgrades/merge), [formally Ethereum 2.0](https://blog.ethereum.org/2022/01/24/the-great-eth2-renaming/), is still in development but it\u2019s leading implementation is [Casper FFG](https://arxiv.org/pdf/1710.09437.pdf)\xa0[<sup>\\\\[2\\\\]</sup>](https://eips.ethereum.org/EIPS/eip-1011) (there\u2019s also [this](https://vitalik.ca/general/2018/12/05/cbc_casper.html) alternative) which uses a Byzantine Fault Tolerance consensus.\\n\\nIn Proof of Stake, the participants are called validators who\u2019s role is similar to miners in Proof of Work. The validator is staking money on the block that it thinks should be added to the chain. If the block gets appended, then they get a reward that is proportional to the bet that they placed on the block. [<sup>\\\\[1\\\\]</sup>](https://www.chubbydeveloper.com/ethereum-proof-of-stake-casper-ffg-vs-casper-cbc/)<sup> </sup>Validators are responsible for following the forking rules when staking checkpoints. Validators decide which block is the best by following a set of rules.\\n\\n<https://arxiv.org/pdf/1710.09437.pdf>\\n\\nThe proposal set the stake deposit at 32 ETH to be eligible to act as a validator. At the time of writing that has a value of 81,374.81 USD even after a recent drop in value.\\n\\n![ETH Value](https://lh6.googleusercontent.com/yqYvnvnQNbf46dzgQQcndXR8eFjm_LYe-6ND4GslxLlyxtZamkv5q6deQjMVayYz9cHNvzh8UbOwcl4Q897KJEJp_mtCHi0x3WvMWN8b9cG-1zDiLnuQ-lQiBaC2H6D66O-8x2umwhzTkWLbJA)\\n\\nThere\u2019s a few key concepts employed in Casper FFG, many are outlined in the [EIPS 1011\u2019s Glossary](https://eips.ethereum.org/EIPS/eip-1011#glossary)\\n\\n- Checkpoint is the block in the finalization stage\\n- Epoch is the range of blocks between checkpoints. This grow by one block for each new epoch\\n- Dynasty refers to the number of finalized checkpoints in the chain. (Note: checkpoints do not reach finality unless a super-majority of votes are obtained in favor)\\n\\nThe validators are _randomly_ selected (this is not detailed in the proposals but details are available [here](https://github.com/ethereum/casper/blob/4adeffce5709fcf2d36f4bc6ac27bbd62747d032/VALIDATOR_GUIDE.md)) based on who has deposited the correct funds. Participants must deposit the correct sum 2 dynasties in advance to join a validator set. In order to leave they must send a withdrawal request 2 dynasties in advance, however the funds are not returned for approximately 4 months since the withdrawal was requested.\\n\\nConsensus, or finality, is not reached unless \u2154, a super-majority of votes have been gathered stating the checkpoint meets the forking rules \u201cfollow the chain containing the justified \\\\[block] of the greatest height\u201d.\\n\\nWhen a checkpoint is finalized all the blocks in it\u2019s epoch are implicitly finalized as well. This also marks the start of a new dynasty, casting the previous on to history it can no longer be modified and reaches immutability. This is also when validators can enter or exit the staking on checkpoints.\\n\\n## References\\n\\n<https://developer.bitcoin.org/devguide/p2p_network.html?highlight=stale%20orphan#orphan-blocks>\\n\\n<https://developer.bitcoin.org/devguide/block_chain.html?highlight=stale#block-height-and-forking>\\n\\n<https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/>\\n\\n<https://vitalik.ca/general/2017/12/31/pos_faq.html>\\n\\n<https://medium.com/unitychain/intro-to-casper-ffg-9ed944d98b2d>\\n\\n<https://medium.com/@ppio/consensus-byzantine-fault-tolerance-402258ec7a60>\\n\\n<https://ethresear.ch/t/casper-ffg-with-one-message-type-and-simpler-fork-choice-rule/103/31>"}]}')}}]);