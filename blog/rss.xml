<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Pyrsia.io Blog</title>
        <link>https://pyrsia.io/blog</link>
        <description>Pyrsia.io Blog</description>
        <lastBuildDate>Mon, 10 Oct 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Why does Pyrsia use a Blockchain(and no CryptoCurrency)?]]></title>
            <link>https://pyrsia.io/blog/2022/10/10/why-does-pyrsia-use-a-blockchain</link>
            <guid>/2022/10/10/why-does-pyrsia-use-a-blockchain</guid>
            <pubDate>Mon, 10 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.]]></description>
            <content:encoded><![CDATA[<p>Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.</p><p>Blockchain technology is deployed to leverage the following features:</p><ul><li>Distributed ledger: Blockchain implementations use a distributed ledger and perform transactions based on consensus.</li><li>Consensus based commits: Typically blockchain implementations come with an implementation of a Byzantine Fault Tolerance (BFT) * algorithm<!-- -->[1]<!-- -->.</li><li>Transparency and Immutability: Blockchain transactions are transparent and immutable, meaning they cannot be tampered with, thus * increasing trust and confidence in the system.</li><li>Faster transactions: Third party verification is eliminated thus causing faster transactions.</li><li>Improved security: Blockchain transactions embed security within them which can be verified by third parties. Any attempts at adding malicious data make the blockchain invalid thus exposing breaches.</li></ul><p>A software supply chain backed by a consistent verifiable ledger using blockchain brings trust into the open source software world. Also as blockchain commits are typically implemented based on BFT they provide security against failures in a distributed network. This provides protection against malicious network nodes committing data to the blockchain.</p><p>In this blog we discuss how Pyrsia is a tool for securing your software supply chain. We discuss the application of blockchain technology to provide an immutable record of each open source software being built into a binary. We further discuss how other aspects of blockchain technology help us build a distributed system that can scale across the globe.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="software-supply-chain-security">Software Supply Chain Security<a class="hash-link" href="#software-supply-chain-security" title="Direct link to heading">​</a></h2><p>Software supply chain has received much attention since a few well known events have affected the software industry and these have also percolated into real lives of people (eg. Equifax data breach<!-- -->[2]<!-- -->, Solarwinds breach<!-- -->[3]<!-- -->, Log4Shell vulnerability<!-- -->[4]<!-- -->, Spring4Shell vulnerability<!-- -->[5]<!-- --> and many more).
Software supply chain has become a core topic of discussion within the software industry and also caused policy decisions<!-- -->[6]<!-- --> to solidify the security posture across the board.</p><p>The vulnerabilities discussed above and many more that go without receiving so much attention are discovered in the open source libraries that become part of the end user software. Much of this open source software development relies on few people’s effort and on tools that do not give insight into how the said software is being built. Establishing any level of trust becomes a challenge. Furthermore, once this open source software becomes part of the supply chain, we rely on a lot of manual effort to determine the components that are part of the software supply chain.</p><blockquote><p>Our proposal for Pyrsia <!-- -->[7]<!-- -->, a decentralized package network, aims to provide a solution for a key part of the supply chain.
Pyrsia aims to</p><ul><li>Build trust for the open-source packages being used as dependencies in software development through certified and peer-verified builds</li><li>Provide a decentralized package network that understands package coordinates, semantics, and discoverability, and which continues to work even though there are local outages</li></ul></blockquote><p>Pyrsia aims to provide a tool to establish and verify trust in the software delivery world. With Pyrsia we hope to provide a source of information that can be used to automate much of this effort. 75% software comes from open source components<!-- -->[8]<!-- --> and with Pyrsia as the mechanism to manage these components we look towards a future where software is liquid<!-- -->[9]<!-- -->.</p><p>Pyrsia aims to provide trustworthy provenance data which can be used to automate releases, patches and audit activities for the supply chain. Gathering all this information and sharing it with decentralized nodes requires a lightweight and tamperproof database.</p><p>In order to make Pyrsia’s goals successful we need to use a database that can serve the following requirements:</p><ul><li>Performant in a distributed setting</li><li>Tamperproof</li><li>Lightweight enough to be able to stream updates efficiently</li></ul><p>A blockchain implementation is a perfect fit since it provides all the above features and provides the ability to add verification mechanisms on top of it. Let’s talk a little bit more about the current state of the software supply chain.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="state-of-software-supply-chain">State of Software Supply chain<a class="hash-link" href="#state-of-software-supply-chain" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="lack-of-trustworthy-provenance-data">Lack of trustworthy provenance data<a class="hash-link" href="#lack-of-trustworthy-provenance-data" title="Direct link to heading">​</a></h3><p>As it stands today we implicitly rely and trust the central repositories to provide updates to open source libraries. But evidence has shown that such implicit trust is not sufficient to secure the supply chain. There have been instances that show how this trust can be breached either by a rogue agent taking over control from the rightful owner (email squatting, typosquatting 1, typosquatting 2) or even the rightful owner turning rogue for some reason or getting burnt out.</p><p>Overall building a definitive SBOM for your software continues to be a challenge. Querying to determine versions, related vulnerabilities, dependency chains and potential remediation still remains a manual process. Such manual processes are error prone and require investment of effort similar to that of building original software and thus do not get enough attention until disaster has struck.</p><p>Pyrsia started with a goal of building such a provenance log which is easy to use with automation, and scales across a distributed network.</p><p>Pyrsia aims to keep the nodes on the network up to date using a peer to peer update mechanism. This is critical so that many of the Pyrsia functions can be performed on the peer node without having to traverse. the network. The critical part here that needs to be upto date is the provenance log which is powered by the blockchain.</p><p>This provenance log will further support an automation infrastructure to aid software delivery decisions which currently requires manual intervention.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dependence-on-centralized-repositories">Dependence on centralized repositories<a class="hash-link" href="#dependence-on-centralized-repositories" title="Direct link to heading">​</a></h3><p>Realizing that centralized repositories have run their course in terms of being a source of trust and reliability, we started the Pyrsia design with emphasis on being distributed by design.
We need a distributed network since centralized repositories lack the reliability and scale that decentralized systems can provide.</p><p>Pyrsia relies on the peer-to-peer (P2P) communication mechanisms (think bittorrent) to exchange artifacts, metadata about those artifacts and also the provenance log. Pyrsia leverages two different channels to make these network transfers efficient. One channel delivers artifacts and another channel is used to synchronize the blockchain over the network. Artifacts are delivered on demand but the provenance log is updated frequently and this information needs to be lightweight - which is facilitated by the append-only blockchain. Leveraging the P2P technology makes Pyrsia resilient to internet failure modes (data center failures or network failures) and allows the network to scale organically - even across geographical boundaries where data center availability may be a challenge.</p><p>But using this technology also meant that Pyrsia could not rely on traditional data distribution mechanisms (like distributed databases, network caches, CDNs etc). Pyrsia needed a distributed database that was easy to update and transmit (read: serialize) over the network. Since P2P networks are also fault tolerant we needed to ensure that such a database can be usable from the local Pyrsia node (think git).</p><p>Given these constraints/requirements we started thinking about using a blockchain as a possible solution.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="trustworthy-means-tamperproof">Trustworthy means tamperproof<a class="hash-link" href="#trustworthy-means-tamperproof" title="Direct link to heading">​</a></h3><p>The main feature that Pyrsia provides is a reliable and verifiable log for asserting your dependencies. This means that we need a log that is append only, written once and read many times and its entries to be immutable. We need a database that is tamper proof with guarantees of discovering and resolving any malicious additions. Blockchain technology has proved to be one of those immutable databases.</p><p>Hence we chose a Blockchain technology that acts as an immutable ledger for the purpose of storing all data related to artifacts. Furthermore as we mentioned before  Blockchain implementation requires a consensus mechanism based on BFT to ensure that there is security against taking over the network. An implementation of Blockchain implements BFT to ensure there is consensus for each block of data committed. BFT algorithms are resilient against network attacks that span the network and can tolerate upto ⅓ of the network failures. For a reasonable sized network getting control of ⅓ of the network nodes is a costly operation for hackers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pyrsia-design">Pyrsia Design<a class="hash-link" href="#pyrsia-design" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="provenance-log">Provenance Log<a class="hash-link" href="#provenance-log" title="Direct link to heading">​</a></h3><p>Pyrsia is built to provide a Provenance log to provide enough information about open source software. This information can be used to build decision making automation to enable releases and control what can be released. This provenance log is built to be lightweight so that a large number of software binaries can be tracked efficiently. In order to store such a provenance log we need a storage solution that has auditable and verifiable links that connect to history. Blockchain or immutable ledgers provide an efficient mechanism to store such chains of information and allow for quick retrieval.</p><p>Another feature Pyrsia is building is a search engine that can provide provenance log for each version, each binary type and each binary name. Pyrsia needs to parse this information quickly so that search indexes remain current at all times..Compared to the heavy footprint of the artifacts themselves the blockchain is much more lightweight and intends to keep itself that way. As the ecosystem grows this database will grow in size but still remain magnitudes smaller than the artifact storage.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="network-structure">Network Structure<a class="hash-link" href="#network-structure" title="Direct link to heading">​</a></h3><p>Pyrsia’s design contains a network structure that provides direct connectivity between peers thus allowing for immense scale. Having said that, given the emphasis on security we have a differentiation between nodes that run in the cloud and the ones that are run on individual/volunteer nodes. The nodes that run on the cloud have the ability to act as a large cache, have better network throughput thus providing a bigger conduit to reach the repositories. The volunteer nodes provide a P2P network, a sort of proxy cache to content and an effective distribution mechanism. The authority nodes are the only ones that can commit to the ledger and thus provide a trustworthy provenance log.</p><p><img loading="lazy" alt="Pyrsia Network Design" src="/assets/images/provenance_log_architecture-35063e6d133a93eff6748500a10ad689.png" title="Pyrsia Network" width="1838" height="1766" class="img_ev3q"></p><p>Along with this the nodes on the cloud are deployed and maintained by Pyrsia governing organizations (Governing organizations are listed on <a href="https://pyrsia.io/" target="_blank" rel="noopener noreferrer">https://pyrsia.io/</a>). Having these owned by organizations instead of individuals enhances the availability of these nodes as well as vastly improves the security posture. We are now able to verify these nodes, provide identity mechanisms to have a provable chain of authority and provide membership privileges to keep the network secure - while scaling it across regions.</p><p>This network structure allows us another luxury, that of ensuring we control the data that is being committed to the blockchain. Early on we decided that Pyrsia will only allow the cloud nodes to commit to the blockchain using a consensus mechanism. This consensus mechanism will only allow authorized cloud nodes to commit and thus reduce the complexity of the consensus mechanism. Another aspect we realized is that, given Pyrsia will have very limited participants being able to commit to the blockchain we can stay away from the expensive, mining heavy, at times quite wasteful algorithms. Thus we steered clear from investing into the Proof of Work, Proof of Stake and similar algorithms. We have been focusing on using the Proof of Authority which has significantly reduced the complexity while providing us with sufficient control to keep the network secure.</p><p>In this design the authority is assigned and cannot be obtained through the means that are used on the open networks. Pyrsia governance organizations approve every node that has the authority to commit to the blockchain. This furthers our goal of providing a trustworthy network which has more control over what is available on the network. The Authority nodes are the only ones committing to the blockchain and then transmitting those updates to the peer nodes.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="leveraging-the-blockchain-technology">Leveraging the Blockchain technology<a class="hash-link" href="#leveraging-the-blockchain-technology" title="Direct link to heading">​</a></h2><p>Given the above criteria and constraints and evidence of success of the blockchain technology we found that the right fit for Pyrsia’s provenance log - which is its source of truth - using an implementation of blockchain technology was the right choice for Pyrsia.</p><p>We further assessed available implementations of blockchain and narrowed our choice of implementation based on the following criteria:
Availability of multiple language support - especially good documentation for a Rust implementation
Ability to turn of or not have the concept of Currency to make transactions on the network
Ability to choose the consensus algorithms that fit Pyrsia’s need and situation - Proof of Authority</p><p>We found that AlephBFT supported all these criteria and was easy to get started. We have been able to also build on top of AlephBFT to constrain the use cases of Pyrsia without giving away security. AlephBFT has also allowed us to configure the network nodes in a way that allows us the control we need to support the security.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="blockchain-does-not-mean-crypto">Blockchain does not mean Crypto<a class="hash-link" href="#blockchain-does-not-mean-crypto" title="Direct link to heading">​</a></h2><p>One thing we have learnt over the course of this effort is that - whenever we talk about blockchain as the technology we use in Pyrsia, we have received critical feedback about how we are overcomplicating our design. When we reflected on this feedback we realized that the majority of it is due to the prevalent use of blockchain within the cryptocurrency world.</p><p>Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it automatically gets associated with cryptocurrency and mining. And we have found that it is really hard to break this association. We also found that the most popular implementations connect the mining and crypto aspects to the blockchain in such a way that they become inseparable.</p><p>Blockchain will act as the immutable ledger giving us the tamper proof database we need, with the ability to search it efficiently and distribute it across the peers as we need.</p><p>Pyrsia is open source and free. The key to ensuring that the open source community continues to engage and use Pyrsia is that there should not be any currency attached with actions on Pyrsia. From the get go this has been our main objective to keep this network free and open to use for the community and we have worked to implement an immutable ledger which does not have the concept of cryptocurrency in it. Our implementation has removed the requirement of requiring gas (a fuel to power your transactions on the blockchain) or currency for participation. Given the security concerns Pyrsia operates on a small number of Pyrsia nodes that participate in consensus. Running the Proof of Authority algorithm from certified nodes and limiting those number of nodes to the participants of the governing board, allows Pyrsia to maintain security without being open to any mining on the network. Pyrsia will also benefit from the lightweight implementation of AlephBFT so that we can scale across regions and keep the network always up to date.</p><p>Pyrsia aims to leverage blockchain to power the provenance data while not allowing any usage of cryptocurrency on the network. We believe that open source should be free to use and should not have incentives attached to it to allow for fairness. Pyrsia builds on the success of blockchain while saving resources (energy) by not allowing any competitive currency exchange on the network.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="in-summary">In Summary<a class="hash-link" href="#in-summary" title="Direct link to heading">​</a></h2><p>Pyrsia leverages blockchain as an immutable ledger to provide a scalable provenance log. Blockchain technology is best suited for distributed large amounts of chained data across wide networks which is evidenced from the success of blockchain in the cryptocurrencies. Pyrsia is using this same technology to improve the state of the software supply chain by providing transparency into how open source software is being built on this network. This transparency is aimed to give you the confidence to use the open source library in your production environments.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h3><ul><li><a href="https://decrypt.co/resources/byzantine-fault-tolerance-what-is-it-explained" target="_blank" rel="noopener noreferrer">Byzantine Fault Tolerance</a></li><li><a href="https://www.synopsys.com/blogs/software-security/equifax-apache-struts-vulnerability-cve-2017-5638/" target="_blank" rel="noopener noreferrer">Equifax data breach</a></li><li><a href="https://www.businessinsider.in/tech/news/heres-a-simple-explanation-of-how-the-massive-solarwinds-hack-happened-and-why-its-such-a-big-deal/articleshow/79945993.cms" target="_blank" rel="noopener noreferrer">Solarwinds breach</a></li><li><a href="https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/" target="_blank" rel="noopener noreferrer">Log4Shell vulnerability</a></li><li><a href="https://jfrog.com/blog/springshell-zero-day-vulnerability-all-you-need-to-know/" target="_blank" rel="noopener noreferrer">Spring4Shell vulnerability</a></li><li><a href="https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/" target="_blank" rel="noopener noreferrer">Executive order on improving nations cybersecurity</a></li><li><a href="https://pyrsia.io" target="_blank" rel="noopener noreferrer">Pyrsia Proposal</a></li><li><a href="https://www.synopsys.com/software-integrity/resources/analyst-reports/open-source-security-risk-analysis.html?intcmp=sig-blog-rsa22" target="_blank" rel="noopener noreferrer">75% software comes from open source components</a></li><li><a href="https://jfrog.com/whitepaper/a-vision-of-liquid-software/" target="_blank" rel="noopener noreferrer">Software is Liquid</a></li></ul>]]></content:encoded>
            <category>blockchain</category>
            <category>consensus</category>
            <category>cryptocurrency</category>
            <category>proof-of-work</category>
            <category>proof-of-stake</category>
            <category>security</category>
            <category>transparency</category>
            <category>provenance</category>
        </item>
        <item>
            <title><![CDATA[Why Pyrsia is being built in Rust?]]></title>
            <link>https://pyrsia.io/blog/2022/09/30/why-pyrsia-is-being-built-in-rust</link>
            <guid>/2022/09/30/why-pyrsia-is-being-built-in-rust</guid>
            <pubDate>Fri, 30 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.]]></description>
            <content:encoded><![CDATA[<p>When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="securing-open-source-software">Securing Open Source Software<a class="hash-link" href="#securing-open-source-software" title="Direct link to heading">​</a></h2><p>Open source software is built mostly by people passionate about solving a problem and sharing their solutions widely. One of the differences in how we build proprietary software vs open source is that we find that many of those original developers do their best in keeping the software upto date and try to patch vulnerabilities as soon as they can. Although their efforts are usually the best they can do. In some well publicized cases, developers have experienced burnout and lack of interest in supporting what they built, due to resource constraints.</p><p>For proprietary software, there are well published processes and patterns which are used to build software and record how it was done. Open Source software usually does not get this rigor and often is found vulnerable.</p><p>On Pyrsia we focus on this missing piece of building open source software and are building a platform that offers build from source service while providing a record of how it was done. Pyrsia leverages a peer-to-peer distribution model for these binaries thus making the network resilient to failures.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="secure-software-needs-a-secure-platform">Secure Software needs a secure platform<a class="hash-link" href="#secure-software-needs-a-secure-platform" title="Direct link to heading">​</a></h3><p>While the aim of Pyrsia is to secure the software that it builds, a lot of trust/community involvement expects the network itself to be secure. Pyrsia as a platform has taken this expectation seriously and from the initial days invested a lot of energy into building it right.</p><p>A few other considerations that were made during the initial discussions of Pyrsia include:</p><ul><li>Decentralized network (think Web3) to leverage distribution of binaries across regions</li><li>Build from source using independent randomly chosen nodes to ensure security by reducing surface of attack</li><li>Consensus mechanism to ensure that multiple nodes participate in the build and verification process</li><li>Deploying Pyrsia node instances on wide variety of architectures, operating systems, as well as footprints(think Intel Xeon all the way to Raspberry * Pi and beyond)</li><li>Ensuring wide deployments have a minimal footprint - for transportation, but more importantly to further reduce the possibility of attacks</li><li>Modern software that allows system programming - to enhance experience and also to restrict how the data structures can be used. Constraining how the software is built is key to making it more secure.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="choosing-a-programming-language">Choosing a programming language<a class="hash-link" href="#choosing-a-programming-language" title="Direct link to heading">​</a></h2><p>For Pyrsia to address the above considerations we weighed them against a few popular languages with decent community voice and size.</p><p>Specifically we were looking for the following in a programming language ecosystem:</p><ul><li>Welcoming community - People come first</li><li>Modern language constructs that help us focus on the problem instead of the language</li><li>Secure or easily to build for security</li><li>Multiple OS and Arch support</li><li>Ability to drop down to lower level to help implement any cryptography, improve performance</li><li>Support for web3 implementations like p2p networking, blockchain, cryptography</li><li>Installed base of system software in the language</li></ul><p><a href="http://rustlang.org" target="_blank" rel="noopener noreferrer">Rust</a> seemed to satisfy all these requirements, in fact with flying colors.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="rust-language">RUST Language<a class="hash-link" href="#rust-language" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rust-philosophy-1">Rust philosophy <!-- -->[1]<a class="hash-link" href="#rust-philosophy-1" title="Direct link to heading">​</a></h3><blockquote><p>Today we are very proud to announce the 1.0 release of Rust, a new programming language aiming to make it easier to build reliable, efficient systems. Rust combines low-level control over performance with high-level convenience and safety guarantees. Better yet, it achieves these goals without requiring a garbage collector or runtime, making it possible to use Rust libraries as a "drop-in replacement" for C.</p></blockquote><p>What makes Rust different from other languages is its type system, which represents a refinement and codification of "best practices" that have been hammered out by generations of C and C++ programmers. As such, Rust has something to offer for both experienced systems programmers and newcomers alike: experienced programmers will find they save time they would have spent debugging, whereas newcomers can write low-level code without worrying about minor mistakes leading to mysterious crashes.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="history-of-rust-2">History of Rust <!-- -->[2]<a class="hash-link" href="#history-of-rust-2" title="Direct link to heading">​</a></h3><blockquote><p>Rust began as a side project of Graydon Hoare, an employee at Mozilla. In short order, Mozilla saw the potential of the new language and began sponsoring it, before revealing it to the world in 2010.
One possible source of the name, according to Hoare, is the rust fungus. This has caused Rust programmers to adopt “Rustaceans” as their moniker of choice.</p><p>Despite its relative youth, Rust has steadily risen in the ranks of popular programming languages. In fact, while it ranked 33 in July 2019, by July 2020 it had risen to the 18th spot on the <a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener noreferrer">TIOBE Programming Community Index</a>. Similarly, according to <a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener noreferrer">Stack Overflow Developer Survey</a>, Rust has been the <code>most loved</code> language since 2016.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rust-language-ecosystem">Rust language ecosystem<a class="hash-link" href="#rust-language-ecosystem" title="Direct link to heading">​</a></h3><p>The above philosophy made Rust a great candidate for use in security solutions like Pyrsia. Some other aspects that sealed the deal as a programming language for us were:</p><ul><li>Performance close to equivalent C level programs <!-- -->[3]</li><li>Concurrent programming without the garbage collection <!-- -->[4]</li><li>Rust has a borrow checker which ensures references do not outlive the data</li><li>Rust can be compiled to reduced instruction set architectures</li></ul><p>Along with the above, we also found that the initial set of libraries(libp2p, AlephBFT) we were looking to support, had mature implementations in rust. Also we found that the communities that supported these libraries were welcoming all implementers and learners alike. This openness within the Rust community in general made the choice easier for us.
A lot of these appealing features of the Rust ecosystem are well summarized in <!-- -->[5]<!-- -->.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="summary">Summary<a class="hash-link" href="#summary" title="Direct link to heading">​</a></h2><p>When we set out to change how open source software is secured we had a choice to make - the language to build the security solution with. When we surveyed what was available there were multiple options. C due to its performance, Golang because of its mature installations in the wild, Rust as an up and coming community with performance and modern language features.</p><p>In the end it was clear to us that Rust was the right choice to make and we have started building Pyrsia in Rust. We realize that we have a steep learning curve and we are learning as a group. Come join us on our <a href="https://cdeliveryfdn.slack.com/join/shared_invite/zt-1eryue9cw-9YpgrfIfsTcDS~hGHchURg" target="_blank" rel="noopener noreferrer">Slack channel</a> to discuss more.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h3><ul><li><a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html" target="_blank" rel="noopener noreferrer">Rust Philosophy</a></li><li><a href="https://www.talentopia.com/news/the-rust-programming-language-its-history-and-why/" target="_blank" rel="noopener noreferrer">Rust History</a></li><li><a href="https://codilime.com/blog/rust-vs-c-safety-and-performance-in-low-level-network-programming/" target="_blank" rel="noopener noreferrer">Rust vs C</a></li><li><a href="https://discord.com/blog/why-discord-is-switching-from-go-to-rust" target="_blank" rel="noopener noreferrer">Garbage collection issues</a></li><li><a href="https://codilime.com/blog/why-is-rust-programming-language-so-popular/#:~:text=High%20performance%20and%20safety%20are,amounts%20of%20data%20very%20quickly" target="_blank" rel="noopener noreferrer">Why projects use Rust?</a></li></ul>]]></content:encoded>
            <category>rustlang</category>
            <category>rust</category>
            <category>security</category>
            <category>web3</category>
            <category>modern</category>
            <category>safety</category>
            <category>community</category>
            <category>ecosystem</category>
        </item>
        <item>
            <title><![CDATA[Peer Metrics in the Pyrsia Network]]></title>
            <link>https://pyrsia.io/blog/2022/06/03/peer-metrics</link>
            <guid>/2022/06/03/peer-metrics</guid>
            <pubDate>Fri, 03 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and "fast". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.]]></description>
            <content:encoded><![CDATA[<p>Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and "fast". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.</p><p>Herein I present the mechanism the Pyrsia team has created to help improve the selection process for downloading software distributions from peers. The idea is to improve upon the Kademila peer selection process and make "smarter" choices from Pyrsia peers based on a "peer metric". The mechanism is layered atop the Kademila peer selection process, which in Pyrisa returns a list of peers known to be in possession of an open-source distribution of interest. The peer metric is a real time assessment of the work-load of any given machine in the network, both related and unrelated to any current software transfers within the Pyrsia network.</p><p>The following table defines terms used in this blog.</p><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Requester</td><td>In this context a requestor is a Pyrsia client requesting a file to be downloaded or uploaded to/from its peer(s).</td></tr><tr><td>Peer (Pyrsia Peer)</td><td>Any Pyrsia client that is participating in the network.</td></tr><tr><td>Neighboring Node</td><td>Any node that is returned by the Kademila algorithm as having a software distribution desired by a peer.</td></tr></tbody></table><p>As previously stated, a primary goal of the peer-to-peer software distribution sharing function of Pyrsia is that it efficiently uses peers. The efficient use of peers can be broken down into two aspects, efficiencies related to uploading software distributions to peers and efficiencies related to downloading software distributions from peers. This post limits the discussion to downloading software distributions from peers.</p><p>The primary rule defined by our selection process is that requesters must not overwhelm peers by requesting too many software distributions too often from any one neighboring node. Though hard resource usage limits are a configuration function for Pyrsia Peers, Pyrsia’s peer selection mechanism should also attempt to balance requests across the network of peers. Additionally, the peer selection mechanism should operate such that file requesters are not starved for bandwidth in the network by unresponsive peers, preventing fast downloads. While the first efficiency could be guaranteed by Pyrsia policy, the second one is more nebulous because Pyrsia cannot guarantee enough stable network peers exist at request times to achieve “fast downloads”.</p><p>The terms “fast downloads” and “requesting too much data” must be further defined to quantify what is meant. The means of describing these terms can be defined as a function of the attributes within the environment. There are measurable attributes of both the network and the Pyrsia peers participating in the networks that can help us define metrics to balance requests. These metrics will ultimately determine the quality of peers in the requesters' peer list. The term quality in this context is related to the ability of a peer to satisfy a request for download and will be defined by the function Q(x):</p><p><img loading="lazy" src="https://latex.codecogs.com/svg.image?Q(x)&amp;space;=&amp;space;%5Csum_%7Bn=1%7D&amp;space;%5E%7Bpa%5C&amp;space;count%7D&amp;space;pa_n&amp;space;*&amp;space;weight" alt="$Q(x) = \sum_{n=1} ^{pa\ count} pa_n * weight" class="img_ev3q"></p><p>where <code>pa</code> is a peer attribute of the environment and <code>weight</code> is a number that determines the expense of the attribute. The quality number will be calculated on demand by peers returned in the list of peers generated by the Kadimela algorithm. The quality function can be used for either upload quality or download quality depending on the need. The metric is currently used during the selection process for downloading software distributions. Finally, we need to define what characteristics are important to drive analytics for decisions about transactions on the network. The following table lists the attribute used by to Pyrsia generate the peer metric in Pyrsia. The peer with the lowest number is considered to be the ideal candidate for the software distribution download.</p><table><thead><tr><th>Peer Attribute</th><th>Definition</th></tr></thead><tbody><tr><td>Peer Network Load</td><td>A measurement of the current network bandwidth usage in terms packets in and packet out summed over all network interfaces.</td></tr><tr><td>CPU Load</td><td>The average CPU load over the last minute</td></tr><tr><td>Disk I/O Load</td><td>A measure of the current packets being read and written summed over all current processes on the system</td></tr></tbody></table><p>This system of measuring the quality of peers will evolved over time and as other attributes are defined, they will be integrated into the Pyrsia network.</p>]]></content:encoded>
            <category>p2p</category>
            <category>peer-metrics</category>
        </item>
        <item>
            <title><![CDATA[Blockchain Consensus]]></title>
            <link>https://pyrsia.io/blog/2022/01/28/blockchain-consensus</link>
            <guid>/2022/01/28/blockchain-consensus</guid>
            <pubDate>Fri, 28 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Blockchain technologies are trending. There’s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.]]></description>
            <content:encoded><![CDATA[<p>Blockchain technologies are trending. There’s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-is-a-blockchain">What is a Blockchain<a class="hash-link" href="#what-is-a-blockchain" title="Direct link to heading">​</a></h2><p>IBM has one of my <a href="https://www.ibm.com/topics/what-is-blockchain" target="_blank" rel="noopener noreferrer">favorite definitions</a>:</p><blockquote><p>&nbsp;Blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets <!-- -->[<!-- -->... on] a network.
An asset can be tangible (a house, car, cash, land) or intangible (intellectual property, patents, copyrights, branding). Virtually
anything of value can be tracked <!-- -->[<!-- -->... ] on a blockchain network, reducing risk <!-- -->[<!-- -->...] for all involved.</p></blockquote><p>There’s a few key items to highlight from this definition are:</p><ul><li>A shared, immutable ledger</li><li>Recording and tracking assets</li></ul><p>Simply put, a Blockchain is a list of changes to assets, called transactions, which are grouped in blocks that are recognized by all participants in the network.</p><p>Unfortunately, it leaves out one major element. How do blockchain networks reduce risk? How do blockchain networks agree on the shared ledger?</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consensus">Consensus<a class="hash-link" href="#consensus" title="Direct link to heading">​</a></h2><p>In the world of blockchain, consensus is the agreement of which block is next. Collectively all the participants in the blockchain’s network
should come to the same conclusion.</p><p>You’ve probably heard of “Proof of Work”, usually called mining, and “Proof of Stake”, these two are the most popular in terms of market share
in the crypto markets.</p><p>These consensus algorithms were some of the first to be popularized by projects like Bitcoin and Ethereum. These are far from the only ones, Proof of Authority, Proof of Burn, Proof of Capacity and Proof of History are just from others mentioned on <a href="https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp" target="_blank" rel="noopener noreferrer">Investopedia's Website</a>.</p><p>Let’s dive deeper into the two popular algorithms to see how they obtain consensus.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="proof-of-work">Proof of Work<a class="hash-link" href="#proof-of-work" title="Direct link to heading">​</a></h3><p>Proof of Work is based on a mathematical expression which is very costly to compute a magic number, called a nonce, but easily verified. Each participant, typically referred to as a miner, begins the calculation with the transitions it’s heard on the network since the last published block. Participants race each other to find the right answer and the winner traditionally gets a reward. It’s difficult to cheat and very rewarding to operate in good faith.</p><p>At the time of writing, January 28th 2022, the reward is 6.25 BTC which is worth 236,755 USD. It’s easy to draw parallels to the 1849 Gold Rush.</p><p><img loading="lazy" src="https://lh4.googleusercontent.com/lbGxZlJRF5GlNLNmbQlnS7Rdk0CHU9w2QjyfghfFLKWOa-bz7ZaEq83AWwVwEd4oJXZgUhyBQxzZ_-_6ytuISeQXU1er77nfwYpdoPgaE_8bvQqKFdsLmUVRbuc9NrePRDTtcZ7YbkqgTq5RMg" alt="BitCoin Value" class="img_ev3q"></p><p>When miners hear of a new block, they immediately stop their calculation and begin listening for more transactions. This is approximately a 10 minute window for Bitcoin.</p><p>With a small number of competitors it’s pretty straightforward but when tens of thousands of nodes are involved, what happens if two miners finish at the same time. Who wins?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="proof-of-stake">Proof of Stake<a class="hash-link" href="#proof-of-stake" title="Direct link to heading">​</a></h3><p>Proof of Stake is an investment strategy where committing more capital means you’re more likely to get the reward. <a href="https://www.peercoin.net/whitepapers/peercoin-paper.pdf" target="_blank" rel="noopener noreferrer">Peercoin</a>, a very early PoS implementation, kept the mining of PoW but required less computational complexity the more <em>coinage</em> was staked. If two participants offer the same investment in the next block, which one is rewarded?</p><p>If someone is able to offer more capital for their block to be accepted, are they able to always win? Yes, this is a special type of security exploit called a 51% attack. If the confirmation of the next block is tied to a resource, then an entity which holds a majority stake can take control of the blockchain. Proof of Work is also susceptible to this type of attack.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="stale-and-orphan-blocks">Stale and Orphan Blocks<a class="hash-link" href="#stale-and-orphan-blocks" title="Direct link to heading">​</a></h3><p>Most blockchain’s are actually trees, not linked lists which is what probably comes to mind for young data scientists. This probably comes as a shock but it’s the secret ingredient to solving our racing condition when two participants propose the next block in PoW.</p><blockquote><p>If two nodes broadcast different versions of the next block simultaneously, some
nodes may receive one or the other first. In that case, they work on the first one they received,
but save the other branch in case it becomes longer.
The tie will be broken when the next proof-of-work is found and one branch becomes longer.</p></blockquote><p><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer"><em>Bitcoin: A Peer-to-Peer Electronic Cash System Section 5</em></a></p><p>Chains are made of links that connect to others. This data structure is referred to as a linked list, when a link
points to both it’s parent and child is a doubly linked list. Three sequential blocks being published would make the following chain:</p><div class="mermaid" data-mermaid-src="stateDiagram-v2
    [*] --> Block_1
    Block_1 --> Block_2 : Parent
    Block_2 --> Block_3 : Child
    Block_3 --> [*]">stateDiagram-v2
    [*] --&gt; Block_1
    Block_1 --&gt; Block_2 : Parent
    Block_2 --&gt; Block_3 : Child
    Block_3 --&gt; [*]</div><p>If block 4 was published at the same time as our block 3 a node would have the following tree:</p><div class="mermaid" data-mermaid-src="stateDiagram-v2
    [*] --> Block_1
    Block_1 --> Block_2 : Parent
    Block_2 --> Block_3 : Child
    state Block_2 <<fork>>
        Block_2 --> Block_4 : Nephew
        Block_3 --> Block_5
    Block_5 --> [*]">stateDiagram-v2
    [*] --&gt; Block_1
    Block_1 --&gt; Block_2 : Parent
    Block_2 --&gt; Block_3 : Child
    state Block_2 &lt;&lt;fork&gt;&gt;
        Block_2 --&gt; Block_4 : Nephew
        Block_3 --&gt; Block_5
    Block_5 --&gt; [*]</div><p>Since it’s extremely unlikely that a second pair of blocks would also be published at the same time, the tie is broken when the next sequential block is published. This is block 5 in the diagram above.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="which-branch-should-we-follow">Which branch should we follow<a class="hash-link" href="#which-branch-should-we-follow" title="Direct link to heading">​</a></h4><p>Well, intuitively the “strongest” branch of our tree is the one we should stick with. The strength comes from the amount of work that has gone into making the branch. More work means it’s less likely that someone has cheated or lied.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-validator-sets">Dynamic Validator Sets<a class="hash-link" href="#dynamic-validator-sets" title="Direct link to heading">​</a></h3><p><a href="https://ethereum.org/en/upgrades/merge" target="_blank" rel="noopener noreferrer">Ethereum’s new PoS system named <em>Consensus Layer</em></a>, <a href="https://blog.ethereum.org/2022/01/24/the-great-eth2-renaming/" target="_blank" rel="noopener noreferrer">formally Ethereum 2.0</a>, is still in development but it’s leading implementation is <a href="https://arxiv.org/pdf/1710.09437.pdf" target="_blank" rel="noopener noreferrer">Casper FFG</a>&nbsp;<a href="https://eips.ethereum.org/EIPS/eip-1011" target="_blank" rel="noopener noreferrer"><sup>[<!-- -->2<!-- -->]</sup></a> (there’s also <a href="https://vitalik.ca/general/2018/12/05/cbc_casper.html" target="_blank" rel="noopener noreferrer">this</a> alternative) which uses a Byzantine Fault Tolerance consensus.</p><p>In Proof of Stake, the participants are called validators who’s role is similar to miners in Proof of Work. The validator is staking money on the block that it thinks should be added to the chain. If the block gets appended, then they get a reward that is proportional to the bet that they placed on the block. <a href="https://www.chubbydeveloper.com/ethereum-proof-of-stake-casper-ffg-vs-casper-cbc/" target="_blank" rel="noopener noreferrer"><sup>[<!-- -->1<!-- -->]</sup></a><sup> </sup>Validators are responsible for following the forking rules when staking checkpoints. Validators decide which block is the best by following a set of rules.</p><p><a href="https://arxiv.org/pdf/1710.09437.pdf" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/1710.09437.pdf</a></p><p>The proposal set the stake deposit at 32 ETH to be eligible to act as a validator. At the time of writing that has a value of 81,374.81 USD even after a recent drop in value.</p><p><img loading="lazy" src="https://lh6.googleusercontent.com/yqYvnvnQNbf46dzgQQcndXR8eFjm_LYe-6ND4GslxLlyxtZamkv5q6deQjMVayYz9cHNvzh8UbOwcl4Q897KJEJp_mtCHi0x3WvMWN8b9cG-1zDiLnuQ-lQiBaC2H6D66O-8x2umwhzTkWLbJA" alt="ETH Value" class="img_ev3q"></p><p>There’s a few key concepts employed in Casper FFG, many are outlined in the <a href="https://eips.ethereum.org/EIPS/eip-1011#glossary" target="_blank" rel="noopener noreferrer">EIPS 1011’s Glossary</a></p><ul><li>Checkpoint is the block in the finalization stage</li><li>Epoch is the range of blocks between checkpoints. This grow by one block for each new epoch</li><li>Dynasty refers to the number of finalized checkpoints in the chain. (Note: checkpoints do not reach finality unless a super-majority of votes are obtained in favor)</li></ul><p>The validators are <em>randomly</em> selected (this is not detailed in the proposals but details are available <a href="https://github.com/ethereum/casper/blob/4adeffce5709fcf2d36f4bc6ac27bbd62747d032/VALIDATOR_GUIDE.md" target="_blank" rel="noopener noreferrer">here</a>) based on who has deposited the correct funds. Participants must deposit the correct sum 2 dynasties in advance to join a validator set. In order to leave they must send a withdrawal request 2 dynasties in advance, however the funds are not returned for approximately 4 months since the withdrawal was requested.</p><p>Consensus, or finality, is not reached unless ⅔, a super-majority of votes have been gathered stating the checkpoint meets the forking rules “follow the chain containing the justified <!-- -->[<!-- -->block] of the greatest height”.</p><p>When a checkpoint is finalized all the blocks in it’s epoch are implicitly finalized as well. This also marks the start of a new dynasty, casting the previous on to history it can no longer be modified and reaches immutability. This is also when validators can enter or exit the staking on checkpoints.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><p><a href="https://developer.bitcoin.org/devguide/p2p_network.html?highlight=stale%20orphan#orphan-blocks" target="_blank" rel="noopener noreferrer">https://developer.bitcoin.org/devguide/p2p_network.html?highlight=stale%20orphan#orphan-blocks</a></p><p><a href="https://developer.bitcoin.org/devguide/block_chain.html?highlight=stale#block-height-and-forking" target="_blank" rel="noopener noreferrer">https://developer.bitcoin.org/devguide/block_chain.html?highlight=stale#block-height-and-forking</a></p><p><a href="https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/" target="_blank" rel="noopener noreferrer">https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/</a></p><p><a href="https://vitalik.ca/general/2017/12/31/pos_faq.html" target="_blank" rel="noopener noreferrer">https://vitalik.ca/general/2017/12/31/pos_faq.html</a></p><p><a href="https://medium.com/unitychain/intro-to-casper-ffg-9ed944d98b2d" target="_blank" rel="noopener noreferrer">https://medium.com/unitychain/intro-to-casper-ffg-9ed944d98b2d</a></p><p><a href="https://medium.com/@ppio/consensus-byzantine-fault-tolerance-402258ec7a60" target="_blank" rel="noopener noreferrer">https://medium.com/@ppio/consensus-byzantine-fault-tolerance-402258ec7a60</a></p><p><a href="https://ethresear.ch/t/casper-ffg-with-one-message-type-and-simpler-fork-choice-rule/103/31" target="_blank" rel="noopener noreferrer">https://ethresear.ch/t/casper-ffg-with-one-message-type-and-simpler-fork-choice-rule/103/31</a></p>]]></content:encoded>
            <category>blockchain</category>
            <category>consensus</category>
            <category>bitcoin</category>
            <category>ethereum</category>
            <category>proof-of-work</category>
            <category>proof-of-stake</category>
        </item>
    </channel>
</rss>