<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Pyrsia.io Blog</title>
        <link>https://pyrsia.io/blog</link>
        <description>Pyrsia.io Blog</description>
        <lastBuildDate>Fri, 13 Jan 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Release 0.2.3]]></title>
            <link>https://pyrsia.io/blog/2023/01/13/pyrsia-0.2.3-released</link>
            <guid>/2023/01/13/pyrsia-0.2.3-released</guid>
            <pubDate>Fri, 13 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Announcing First Release of 2023]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="announcing-first-release-of-2023">Announcing First Release of 2023<a class="hash-link" href="#announcing-first-release-of-2023" title="Direct link to heading">​</a></h2><p>Here we wish a Happy New Year 2023 to all contributors, sponsors, CDF community, followers and the DevOps community
members. In this year we will continue on our mission to solve a few high stake issues in Software Supply Chain.</p><p>We are happy to announce the release of <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.3" target="_blank" rel="noopener noreferrer">version 0.2.3</a> today!</p><p>We are our continued journey on a small &amp; frequent release schedule. This is to allow us to release consistently and in
small increments as we decided.</p><p>Here are a few salient features we added to the release:</p><ul><li>Improved release docs with manual more test plan to ensure more confidence on the release and to provide more
transparency.</li><li>A new operation to Pyrsia CLI to remove configuration completely to get a default config automatically as soon as we
initiate a get through various way.</li><li>To provide better onboarding experience to new contributors, we made some significant onboarding doc updates to help
with the understanding of Pyrsia and different toolset and framework we are using.</li><li>In GitHub build pipeline we pinned Windows and OS X version to be more definitive.</li><li>Using libp2p's GossipSub to distribute blocks among peers in more robust fashion.</li><li>Blocked any openssl direct &amp; transitive dependency to avoid clash with ssl provided by the platform.</li></ul><p>Here is a list of features we hope to cover in the upcoming release. They are listed as part of
<a href="https://github.com/pyrsia/pyrsia/milestone/9" target="_blank" rel="noopener noreferrer">the milestone definition</a>.</p><p>Please <a href="https://pyrsia.io/docs/tutorials/quick-installation/" target="_blank" rel="noopener noreferrer">download our installers</a>, try out Pyrsia with Docker and
<a href="https://pyrsia.io/docs/community/get_involved/" target="_blank" rel="noopener noreferrer">let us know</a> if you are looking for something Pyrsia does not support
yet.</p>]]></content:encoded>
            <category>pyrsia</category>
            <category>rust</category>
            <category>onboarding</category>
            <category>upgrade</category>
            <category>0.2.3</category>
            <category>release</category>
        </item>
        <item>
            <title><![CDATA[Authority Nodes]]></title>
            <link>https://pyrsia.io/blog/2023/01/05/authority_nodes</link>
            <guid>/2023/01/05/authority_nodes</guid>
            <pubDate>Thu, 05 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Pyrsia builds consensus based on Proof of Authority which is exercised by the Authority Nodes. Authority nodes are run by trusted Partner organizations who join the Pyrsia community and decide to contribute to the network. More about this architecture was detailed in a the Network Structure of Pyrsia.]]></description>
            <content:encoded><![CDATA[<p>Pyrsia builds consensus based on Proof of Authority which is exercised by the Authority Nodes. Authority nodes are run by trusted Partner organizations who join the Pyrsia community and decide to contribute to the network. More about this architecture was detailed in a the <a href="/blog/2022/10/10/why-does-pyrsia-use-a-blockchain/#network-structure">Network Structure of Pyrsia</a>.</p><p>Authority nodes act as the only legal votes in the Proof of Authority to achieve Consensus on Pyrsia blockchain. Authority nodes are assigned keys to prove membership and they vote using those keys to verify packages on the Pyrsia network. These assigned keys are controlled and regenerated by the Pyrsia governance board. We explain here the process and the technology required to implement this.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pyrsia-security-board">Pyrsia Security Board<a class="hash-link" href="#pyrsia-security-board" title="Direct link to heading">​</a></h2><p>Pyrsia project is working towards the concept of having a group of representatives forming a Security Board to ensure the security of the network and the artifacts served by the network. This board will have the scope of providing process and oversight over the following:</p><ol><li>Pyrsia Network Architecture</li><li>Pyrsia Network Security</li><li>Pyrsia Blockchain Security</li><li>Pyrsia DevOps Practices</li><li>Pyrsia Build Infrastructure Security</li></ol><p>Within the above scope the Security Board will provide a uniform review and regulation process to ensure that rogue elements are not able to control the network. This Security board will be formed with the representative organizations to Pyrsia via an election process.</p><p>As part of the normal functioning of this board, the Pyrsia infrastructure will be evaluated periodically and certified.</p><p>Details of this process will be documented separately under the Community section of the <a href="https://pyrsia.io" target="_blank" rel="noopener noreferrer">Pyrsia website</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="participating-authority-nodes">Participating Authority Nodes<a class="hash-link" href="#participating-authority-nodes" title="Direct link to heading">​</a></h2><p>Any participating organization to Pyrsia is welcome to join the network and host/sponsor hosting an Authority node.
Although Authority nodes will require the approval of the Pyrsia Security Board. Once approved the sponsor of the authority node will have the following responsibilities:</p><ol><li>Sponsor the cloud account and billing to host a large size Pyrsia Authority node - specifications will be provided and updated by the Security Board</li><li>Sponsor and provide DevOps personnel to maintain, update and repair the Pyrsia Authority node</li><li>Submit audit reports to the Security Board to ensure that the Authority node remains secure</li></ol><p>Since Pyrsia Authority Node is open source - the source code, helm charts, deployment processes will be maintained by the Pyrsia team thus making it  easy to install and run the Pyrsia Authority Node in the cloud environment of choice.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="participate-in-proof-of-authority">Participate in Proof of Authority<a class="hash-link" href="#participate-in-proof-of-authority" title="Direct link to heading">​</a></h2><p>Once the infrastructure is up and running on the cloud, the Pyrsia nodes become part of the Pyrsia libp2p network and can download, search the Pyrsia network. In order to make these Pyrsia nodes part of the Consensus network this deployment will require some way to gain that authority.</p><p>Since we need to maintain a small but reliable and tamper-proof network access to authority will be limited. Only the participating organizations will have the ability to contribute authority nodes. A people driven process will be in place that determines the readiness of this new participating organization. The security board will drive this process and lay out guidelines to make it transparent.
The security board will also have the ability to assign authority keys to new participant organizations so that they can become part of the consensus process. Only approved Authority Nodes get an authority key.</p><p>Each organization will receive one key that will allow them to participate in voting and publishing packages to the network. This publishing process will allow them to commit new versions of packages or new packages to the Pyrsia network.</p><p>Security Board also reserves the right to revoke authority keys in case the keys or the authority nodes themselves get compromised. Security Board will review the devops practices periodically and suggest a refresh of the authority keys to ensure continued security of the immutable ledger.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="growing-the-network">Growing the network<a class="hash-link" href="#growing-the-network" title="Direct link to heading">​</a></h2><p>Pyrsia released the first working version of the network in our <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0" target="_blank" rel="noopener noreferrer">0.2.0 release</a> which included an Authority node hosted by JFrog. We are working towards adding another Authority node that will run on a different cloud provider's infrastructure and will be releasing it soon.</p><p>While we improve the infrastructure, we are also encouraging organizations to become part of the Pyrsia network and contribute Authority nodes and infrastructure to the network. If you are one of those organizations we would love to chat with you. Our goal is to make this network as distributed as possible - which allows Pyrsia artifacts to reach all the corners of the known internet as well as helps to keep the network running.</p><p>Don't hesitate to reach out to us!</p>]]></content:encoded>
            <category>authority</category>
            <category>consensus</category>
            <category>proof of authority</category>
            <category>cloud</category>
            <category>deployment</category>
            <category>immutable ledger</category>
            <category>BFT</category>
            <category>security board</category>
        </item>
        <item>
            <title><![CDATA[Pyrsia Anniversary Recap]]></title>
            <link>https://pyrsia.io/blog/2022/12/30/pyrsia-anniversary-recap</link>
            <guid>/2022/12/30/pyrsia-anniversary-recap</guid>
            <pubDate>Fri, 30 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[It is hard to believe, but it has happened nevertheless. We have successfully completed a year around the sun, Pyrsia and the team that works on it. And what a year it has been.]]></description>
            <content:encoded><![CDATA[<p>It is hard to believe, but it has happened nevertheless. We have successfully completed a year around the sun, Pyrsia and the team that works on it. And what a year it has been.
From lots of uncertainty, answering difficult questions, working with the Linux foundation, getting ready for CD Foundation, becoming part of CD Foundation and being able to consistently deliver new functionality. I want to take this opportunity to make note of some of the beautiful moments in the last year and wishing for more of those in the future.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="all-about-the-supply-chain">All about the Supply chain<a class="hash-link" href="#all-about-the-supply-chain" title="Direct link to heading">​</a></h2><p>It all began with some initial ideas from Stephen Chin(@steveonJava) where the goal was to do something about the state of supply chain security. This came with a background in Devops where we witnessed many organizations either facing similar problems as those in the case of the SolarWinds attack or worrying about them. In both cases the confidence in software build processes was taking a hit. With the mission of improving the transparency in the supply chain we put together a proposal to kickoff Pyrsia. In the initial days we were juggling multiple conflicting requirements - where are we going to store those artifacts, how do we verify them, will the network be resilient to attacks, how we will deploy, and many many more.</p><p>We saw many organizations big and small jump on the Supplychain Security hashtag and start making some noise about its seriousness. What we witnessed was that these efforts started with big hearts and focused mostly on some kind of cryptography to secure the output of the supply chain. As we looked more closely at the problem we started noticing that the core issue was not about the output but <em>how</em> the output came about. Questions that we pondered were : What about the process that went into identifying what is being built? How about the build process itself? How do we verify the integrity? and so on.</p><p>Pyrsia started with taking all those into consideration and building a process to generate the desired artifacts. Pyrsia contained the promise of building from source, providing transparency and resilience from network failures or attacks. As we started understanding our mission in the early days we were starting to answer some of the above questions and also the ones that were raised during the implementation. Largely as I remember the first few weeks were spent questioning the fundamentals over building something. As we started getting more insight and as we tinkered with Rust some of the ideas were maturing and getting ready to be built into real software.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="security-taken-for-granted">Security taken for granted<a class="hash-link" href="#security-taken-for-granted" title="Direct link to heading">​</a></h2><p>Before the SolarWinds attack and widespread news attention it received, security was taken for granted. Open source software continues to be built by individuals using trust metrics that work in real life. These trust mechanisms like <code>sharing commit access/publish rights, with other contributors was a widespread community practice</code> listed in <a href="https://increment.com/open-source/the-rise-of-few-maintainer-projects/" target="_blank" rel="noopener noreferrer">Rise of few-maintainer projects</a> create a weak infrastructure that all software projects rely on. This worked as long as the awareness as well as impact was limited. With growing reliance on software from keeping the lights on to keeping us healthy and everything in between, this model of <em>trust</em> does not scale.</p><p>Pyrsia started to challenge this status quo and provide a better, available, transparent supply chain for your software.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="navigating-the-technology-space">Navigating the technology space<a class="hash-link" href="#navigating-the-technology-space" title="Direct link to heading">​</a></h2><p>In the initial days the mission was getting clearer while we were researching and prototyping Everything!. Everything included - networking technologies, blockchain ledgers and technologies, programming in Rust and putting it all together. As we did this we were able to identify goals that we could incrementally build towards. We started with the aim of building a working version of the decentralized network that would let users download packages from peers. With this as our minimal requirement we experimented with different tools that could help us deliver.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="learning-rust">Learning Rust<a class="hash-link" href="#learning-rust" title="Direct link to heading">​</a></h3><p>As we talked about our choice of language for this effort, Rust was something we started to learn and gain some experience with. As with any new language we found similar struggles while starting out with Rust. Initial days were mostly frustrations around the syntax and the toolchain. Although as we reflected on our struggles we realized that some of the typical decisions that triggered debates were already in place - for eg. how we organize Rust code, how the toolchain can be used, code linting and code organization. <a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener noreferrer">The Rust Programming Language Book</a> was quite useful in guiding us along and answering some of our questions about building an idiomatic Rust codebase.</p><p>As I reflect on how we have learnt Rust I would say we complained, we got tired of complaining, we made peace with Rust and now our ride is getting smoother. I would say there are still situations which stump us from time to time, but they prove to be more educational instead of frustrating as they were before.</p><p>I was able to talk more about Rust language and our journey so far at the recent <a href="https://www.meetup.com/rust-london-user-group/events/289909563?utm_medium=referral&amp;utm_campaign=share-btn_savedevents_share_modal&amp;utm_source=link" target="_blank" rel="noopener noreferrer">Rust London Meetup</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="decentralized-network---libp2p">Decentralized Network - libp2p<a class="hash-link" href="#decentralized-network---libp2p" title="Direct link to heading">​</a></h3><p>Finding the right open source project that can help us build a decentralized network was a new challenge for us. At least one of our team members had some interest and background in networking(although it turns out experience building networking hardware helps, but there is still a lot of learning when it comes to networking software stack). So we started our research and landed on the <a href="https://ipfs.io" target="_blank" rel="noopener noreferrer">ipfs project</a>. This team had been doing some great working in building a scalable decentralized network using peer-to-peer networking. Incidentally a lot of their examples and experiments happen in Javascript and Golang. But to our pleasant surprise we were able to find the <a href="https://libp2p.io/" target="_blank" rel="noopener noreferrer">libp2p</a> library was already being built in Rust and very close in feature set vis-a-vis the Golang implementation. This was great news for us - in that it would save us valuable energy and time in porting or rewriting existing software.</p><p>Although, libp2p integration was not simple. We went through some cycles trying to understand selecting the feature set that was minimal and required for Pyrsia. As we continue using libp2p we are getting a better understanding of how it is being built as well as understand how it could be improved. libp2p community has made it easy to interact and has given us a warm welcome to their architecture meetings and general discussion.</p><p>Most recently Elliott was able to attend the libp2p day at the ipfs.camp and <a href="/blog/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp/">talk about Pyrsia and its use of libp2p to conquer the world</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="immutable-ledger">Immutable ledger<a class="hash-link" href="#immutable-ledger" title="Direct link to heading">​</a></h3><p>Pyrsia design had the concept of the transparency log(aka provenance log) from the early iterations. In our view, trust can only be based on transparency and this transparency needs to be protected.
Our research for the blockchain as the immutable ledger yielded some key metrics <a href="/blog/2022/10/10/why-does-pyrsia-use-a-blockchain/">that separated us from the popular use of blockchain - cryptocurrency</a>. With our specific needs and limited scale(significantly limited if you think about the number of nodes involved in decision making) we decided to limit new blocks get added to the blockchain. Every transaction needed to be lightweight to enable limited network traffic and quick transport.</p><p>Most of our research took us to opensource blockchain implementations that were based on/being used for some cryptocurrency purposes. Popular implementation like <a href="https://substrate.io/" target="_blank" rel="noopener noreferrer">Substrate</a> were easy to get started and very user friendly. Although, this specific one tied us tightly to their implementation and the use of some concept of Gas(currency). This forced us to have an incentive mechanism based on currency thus hence rely on some cryptocurrency. None of these constraints make this a usable solution for open source. Pyrsia is intended to be community owned and governed. This does not bode well for a solution that forces a currency and thus an option for anyone to boost their stake by pumping more currency into the system. So Substrate and similar options were not an option for us.</p><p>As we continued to look for solutions that allow us to remain currency free and are built in Rust, we found AlephBFT - an implementation of the Byzantine Fault Tolerance algorithm for consensus. This seemed to be something we could use and work without being burdened by aspects of CryptoCurrency. This was a good sign again since we did not have to build a solution from the ground up.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="building-the-prototype">Building the Prototype<a class="hash-link" href="#building-the-prototype" title="Direct link to heading">​</a></h2><p>Building a prototype was still a challenge because it involved integrating these three things together - Rust, libp2p and AlephBFT. We started with the most basic version of the blockchain that determines consensus based on round robin of the participating nodes. For libp2p, we started with the most generic implementation and learnt our way through tuning it. The interesting part was making it work in Rust using the async mechanisms available. It took us a while to get to a working solution that did not crash on start. We still had memory leak issues that cause different behaviour after we ran the node for a while.</p><p>We were able to resolve some of those errors slowly by moving to a more stable and supported <code>tokio.rs</code> library for all our async processing. Tying it together libp2p made the memory leak go away and provide lot more stability that we had in the previous version.</p><p>When we had it all working we released a <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.1.0" target="_blank" rel="noopener noreferrer">Demo Pyrsia network</a>.</p><blockquote><p>Releasing a working version where documentation matched behaviour and consistently worked on all our machines and the cloud was our first big win! This came after tireless efforts at learning the language, the ecosystem, and the underlying technology while iteratively writing code.</p></blockquote><p>libp2p also provides a way to allow peers to communicate even if they are behind private networks(or NAT routers). This makes it easy to deploy these nodes in different scenarios without the need to engineer the network or create exceptions. Implementing this behaviour proved to be a challenge as well when we started. With some help from the libp2p team and also removing some of the conflicting code helped us get better stability on this feature and release it as part of the prototype release.</p><blockquote><p>From our first release we gained enough confidence to make this improvement and release another patch version right after - <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.1.1" target="_blank" rel="noopener noreferrer">NAT support on Pyrsia</a>.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-real-decentralized-network-makes-its-first-appearance">A real decentralized network makes its first appearance<a class="hash-link" href="#a-real-decentralized-network-makes-its-first-appearance" title="Direct link to heading">​</a></h2><p>With a consistently working application we now had a <code>last known good solution</code> for making further improvements. Our next goal was to commission nodes in the cloud that have the authority(hence called Authority nodes) to be part of the blockchain consensus network.</p><blockquote><p>We released a <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0" target="_blank" rel="noopener noreferrer">decentralized network powered by a cloud node</a> at the CDSummit at Kubecon + CloudNativeCon 2022.</p></blockquote><p>This was our first version where the cloud service was always on. An always on service provided a really easy way to onboard and connect to the network. The <code>get started</code> experience greatly improved in this version, we were able to download docker images and also request docker images that previously did not exist on the network. Now the network was ready to be used by participants at the CDSummit and anyone else who liked to engage.</p><blockquote><p>We were ready for the CD Foundation 2 nights before we went to CDSummit in Detroit.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="becoming-part-of-the-cd-foundation">Becoming part of the CD Foundation<a class="hash-link" href="#becoming-part-of-the-cd-foundation" title="Direct link to heading">​</a></h2><p>Alongside writing the code and developing software we were working with the CD Foundation. Numerous presentations and discussions helped us make the case for Pyrsia. Multiple interactions we had with the Technical Oversight Committee(TOC) and other smaller forums gave us confidence about our preparedness. By this time I had enough practice to be able to answer many of the questions or doubts people had about Pyrsia's goals and mission. We worked through the process of project submission and after a voting exercise we joined CD Foundation as an incubation project.</p><p>After the vote there were still a number of steps to complete to make sure we legally and materially have the right permission structure to become a project that is easy to contribute and take forward.
Overall, I received great support from the Pyrsia team in making code/process changes as we went through transferring shared resources over to CD Foundation. Everytime I was stuck or needed support I was able to get quick help from the team at CD Foundation and Linux Foundation. After the transition to CD Foundation web resources we were able to continue with our usual team rituals like standups, retrospective meetings and community meetings without disruption and function without interruption.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="delivering-frequently-and-regularly">Delivering frequently and regularly<a class="hash-link" href="#delivering-frequently-and-regularly" title="Direct link to heading">​</a></h2><p>Since CD Summit in October we have a stable network, we have been able to up the cadence of our delivery cycles and deliver a new release every month. In case you missed it the following versions have been released since October 2022</p><p><a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.1" target="_blank" rel="noopener noreferrer">v0.2.1 - MacOS service, request new artifacts, simpler configuration</a></p><p><a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.2" target="_blank" rel="noopener noreferrer">v0.2.2 - libp2p upgrade, rust toolchain, clap update for CLI</a></p><p>We are getting into a process where for every release we are able to pick and prioritize our goals and measure our progress towards them during the 2 sprints that follow. We hope to continue this to be able to make small, incremental improvements on Pyrsia.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="looking-into-the-next-year">Looking into the next year<a class="hash-link" href="#looking-into-the-next-year" title="Direct link to heading">​</a></h2><p>On the back of the December release we are getting ready to release v0.2.3 in January 2023. Following that we will continue making a dent in our technical debt and continue progressing towards our next major milestone of releasing Java support by version v0.3.0. Along the way we have a few other significant improvements lined up eg. a scalable build service, wider Authority node network that runs on multiple clouds, an API that will encourage integration with language and package ecosystems and so on.</p><p>I can't wait to get started in 2023 and show off new features to our community.</p><p>I am thankful to the community, the Linux Foundation, the CD Foundation and the many different communities we have now become part of. Without your support and criticism 2022 would not have been what it was for Pyrsia. Pyrsia started as an idea in 2022 but has grown into its own system over this year. Looking forward to growing it further with you together.</p>]]></content:encoded>
            <category>supplychain</category>
            <category>security</category>
            <category>recap</category>
            <category>stable</category>
            <category>releases</category>
        </item>
        <item>
            <title><![CDATA[Release 0.2.2]]></title>
            <link>https://pyrsia.io/blog/2022/12/20/pyrsia-0.2.2-released</link>
            <guid>/2022/12/20/pyrsia-0.2.2-released</guid>
            <pubDate>Tue, 20 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Announcing a new release]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="announcing-a-new-release">Announcing a new release<a class="hash-link" href="#announcing-a-new-release" title="Direct link to heading">​</a></h2><p>We are happy to announce the release of <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.2" target="_blank" rel="noopener noreferrer">version 0.2.2</a> today!</p><p>As we continue to build Pyrsia we are now settling in on a regular release schedule. This is to allow us to release consistently and in small increments.</p><p>Starting this release we are listing the important features we hope to cover in the upcoming release. They are listed as part of <a href="https://github.com/pyrsia/pyrsia/milestone/8" target="_blank" rel="noopener noreferrer">the milestone definition</a>.</p><p>This release added a few important upgrades:</p><ul><li>Upgrade libp2p to 0.50.0</li><li>Upgrade clap for Pyrsia CLI</li><li>Upgrade and pin rust version to 1.64</li><li>Ability to query a requested build's status</li><li>Improvements in error messages</li><li>Documentation fixes and improvements</li><li>Onboarding resources for new developers hoping to learn about Pyrsia and Rust</li></ul><p>A big thing we learnt during this release is the ability to pin our builds to a definitive version of Rust. This simplifies our build and github processes significantly because we will be able to
find the application rust version for every release. <code>Cargo.toml</code> will have that release defined and will be the one place to look for it for any automation.</p><p>While processing the release and testing it we also found an inadvertent dependency being pulled in - openssl. This dependency broke deployments on linux. We were able to discover a fix to use rusttls instead. We discovered this while running github actions that relied on <code>ubuntu-latest</code> instead of the specific LTS version of <code>ubuntu</code> we expected. We have now pinned the version of ubuntu that Pyrsia builds with.</p><p>Overall this will fix some of the issues that were reported to us and also make developer/contributor experience better.</p><p>Please <a href="https://pyrsia.io/docs/tutorials/quick-installation/" target="_blank" rel="noopener noreferrer">download our installers</a>, try out Pyrsia with Docker and <a href="https://pyrsia.io/docs/community/get_involved/" target="_blank" rel="noopener noreferrer">let us know</a> if you are looking for something Pyrsia does not support yet.</p>]]></content:encoded>
            <category>pyrsia</category>
            <category>rust</category>
            <category>onboarding</category>
            <category>upgrade</category>
            <category>0.2.2</category>
            <category>release</category>
        </item>
        <item>
            <title><![CDATA[How Pyrsia is Using libp2p to Take Over the World!]]></title>
            <link>https://pyrsia.io/blog/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp</link>
            <guid>/2022/12/20/using-libp2p-to-take-over-the-world-2022-ipfs-camp</guid>
            <pubDate>Tue, 20 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[IPFS Camp and Libp2p Day]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="ipfs-camp-and-libp2p-day">IPFS Camp and Libp2p Day<a class="hash-link" href="#ipfs-camp-and-libp2p-day" title="Direct link to heading">​</a></h2><p>Heading to <a href="https://2022.ipfs.camp/" target="_blank" rel="noopener noreferrer">IPFS Camp 2022</a> (the 2022 theme is discovering how to use IPFS to build a better web) on Thursday October 27, my flight scheduled for 2:53 pm, racing through Atlanta I realized I forgot my coat half-way to the airport. No time to retrieve it, I found myself aboard United flight 1829 to Newark, NJ arriving at EWR about 2 and a half hours later (without a coat). I was waiting for my connecting flight to Lisbon when they announced a gate change. Walked with the others down to the new gate. In the air at 2035 we arrived at about 0820 Friday morning and made our way to Portuguese customs.</p><p>It is <em>already</em> time, I find a taxi outside the airport. Lucky the taxi drivers' English is far superior to my Portuguese, it cost a mere 10 Euros for the ride to the Convento do Beato and Day 1 of IPFS Camp!</p><p>After a full night of travel I was excited to get into the conference and get technical - however jet lagged.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="day-1">Day 1<a class="hash-link" href="#day-1" title="Direct link to heading">​</a></h2><p>Day 1 is a bit of a blur, as the IPFS Camp speakers regaled us with the latest happenings in IPFS. <a href="https://js.ipfs.tech/" target="_blank" rel="noopener noreferrer">JS-IPFS</a>, <a href="https://fission.codes/blog/ipfs-thing-breaking-down-ipvm/" target="_blank" rel="noopener noreferrer">IPVM</a>, <a href="https://iroh.computer/" target="_blank" rel="noopener noreferrer">Iroh</a> (Rust implementation of IPFS) and Filecoin and NFTs; oh my! I attend the Keynotes, and then learn about plans to “decentralize all of the things!” <a href="https://youtu.be/HRYREdsLt5k" target="_blank" rel="noopener noreferrer">Alternative IPFS implementations</a>, then the IPFS project expo where I was able to experiment with Fission’s IPVM.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="iroh">Iroh<a class="hash-link" href="#iroh" title="Direct link to heading">​</a></h3><p>The <a href="https://youtu.be/qPBR2K2X6cs" target="_blank" rel="noopener noreferrer">Iroh story</a> is compelling, because they have a complete IPFS implementation in Rust.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="js-ipfs">js-ipfs<a class="hash-link" href="#js-ipfs" title="Direct link to heading">​</a></h3><p><a href="https://youtu.be/pXOBE9tfevQ" target="_blank" rel="noopener noreferrer">js-ipfs</a> is interesting, because they’re capable of running in both node and the browser. Might try it in Rhino as well. But these days Rust is the language I use for my primary day to day development at work.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="ipvm">IPVM<a class="hash-link" href="#ipvm" title="Direct link to heading">​</a></h3><p>The <a href="https://youtu.be/rzJWk1nlYvs" target="_blank" rel="noopener noreferrer">IPVM story</a> is also compelling, because they intend to host WASM VMs as potentially a new kind of "serverless" infrastructure. The ability to use distributed data as executable code in a decentralized cloud is fascinating technically.</p><p>Feeling exhausted, and having been awake since Thursday, I took an Uber back to the hotel, checked-in, showered and slept. I note the shower is significantly raised and breakfast is served at 7 am.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="day-2">Day 2<a class="hash-link" href="#day-2" title="Direct link to heading">​</a></h2><p> I breakfast and hop in an Uber and back to the Convento do Beato, where I attended talks on Web 3; especially memorable were <a href="https://ipld.io/" target="_blank" rel="noopener noreferrer">IPLD</a>, <a href="https://guide.fission.codes/developers/webnative/file-system-wnfs" target="_blank" rel="noopener noreferrer">WNFS</a> and <a href="https://github.com/myelnet/rs-graphsync" target="_blank" rel="noopener noreferrer">Graphsync</a>.</p><p><a href="https://youtu.be/J_Q6hF_lPiM" target="_blank" rel="noopener noreferrer">IPLD is a data modeling language</a>. Used to model graph based data structures. Primary use case is for blockchain with-in filecoin.
WNFS is a file system built on top of IPFS. Offers pinning services. This sounds conceptually like what we're building.
<a href="https://github.com/myelnet/rs-graphsync" target="_blank" rel="noopener noreferrer">Graphsync</a> is used by Filecoin for syncing the blockchain. Possibly a good fit for syncing blockchains. Requires IPLD.
The measurement and performance unconference includes many interesting projects, especially <a href="https://docs.testground.ai/" target="_blank" rel="noopener noreferrer">Testground</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="day-3">Day 3<a class="hash-link" href="#day-3" title="Direct link to heading">​</a></h2><p>It's libp2p day so I sit at the presenter's table and prepare for <a href="https://youtu.be/aIxmQKWUjNY" target="_blank" rel="noopener noreferrer">my talk</a>. Internet is spotty (it is a former convent) so I setup my phone as a Hotspot (my fellow presenters are especially grateful) and download the Docker image I intend to use for my talk (it works so much faster when you precache your data, but we really should use something heavier than Alpine); the audience appears to appreciate the demo working at all (as the Internet was not working in the convent at the time) and the demo impresses.</p><p>Answering questions, and interacting with others' at libp2p day yields several insights into behaviors we are seeing in our p2p network. For example, we should be implementing <a href="https://docs.rs/libp2p/latest/libp2p/ping/index.html" target="_blank" rel="noopener noreferrer">PING</a> as that provides a heartbeat mechanism and would allow our peers to timeout far more efficiently (currently can take 12 minutes).</p><p>Once again it is late, Uber to the hotel, eating and sleeping. </p><p>Sadly, now IPFS camp is over, but I am glad that I was able to be here and have these conversations and make great connections!</p><p><img loading="lazy" alt="IPFS Camp 2022 Group Photo" src="/assets/images/2022-ipfs-camp-group-a888a39bb44ab641d9f86ddbe85172b4.png" title="IPFS Camp 2022 Group Photo" width="2048" height="1366" class="img_ev3q"></p><p>Please checkout <a href="https://youtu.be/aIxmQKWUjNY" target="_blank" rel="noopener noreferrer">my talk</a> and the <a href="https://docs.google.com/presentation/d/1rn0NKAoTpxyA2iTPE_8fkEqKI3ke8xu9gnhcLyrm7Dk" target="_blank" rel="noopener noreferrer">slides</a> to learn more about <a href="https://pyrsia.io/" target="_blank" rel="noopener noreferrer">Pyrsia</a>.</p>]]></content:encoded>
            <category>rust</category>
            <category>libp2p</category>
            <category>ipfs</category>
            <category>ipfs-camp</category>
            <category>pyrsia</category>
        </item>
        <item>
            <title><![CDATA[Create macOS Installer for Rust Binary App]]></title>
            <link>https://pyrsia.io/blog/2022/12/02/create-macOS-brew-installer-for-rust-binary</link>
            <guid>/2022/12/02/create-macOS-brew-installer-for-rust-binary</guid>
            <pubDate>Fri, 02 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Recently the Rust programming language has enjoyed the success and thrilled the many developers specially working on]]></description>
            <content:encoded><![CDATA[<p>Recently the Rust programming language has enjoyed the success and thrilled the many developers specially working on
System Level Software and building decentralized applications. When releasing your software, it is usually desirable to
provide an easy to use installer for end users, ideally reducing the configuration burden on users and providing
individual developers with control of how the application should function at the end users environment.</p><p>There are advantages of having installers for your binaries and a few are mentioned here. </p><ul><li>User doesn't need to provide any configuration, environment variables or base directories for the binary to run on users
machine. Rather software manufacturer packages those defaults with the installer.</li><li>User can be alerted in the event of a new version release of the software.</li><li>Developer can have more control on managing context of the app, providing backward compatibility, cleaning up storage
used by the app.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="build-a-small-binary-app-in-rust--create-an-installer">Build a small binary app in Rust &amp; Create an Installer<a class="hash-link" href="#build-a-small-binary-app-in-rust--create-an-installer" title="Direct link to heading">​</a></h2><p>In this sections we will build a small rust binary and an installer for macOS using <a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sample-code-for-the-rust-binary">Sample code for the rust binary<a class="hash-link" href="#sample-code-for-the-rust-binary" title="Direct link to heading">​</a></h3><p>In this example we will exercise a basic rust binary application to demonstrate how to build an installer. The rust program
which listens to a TCP Socket and write the text message on to listener's standard output (i.e. stdout) stream. The
program also has an option to set the port from an environment variable. Final goal is to run the software as a
background process and log the text to Listener's output stream whenever any other application sends message to the
socket.</p><p>Let's create a rust project named <code>rust_app</code> using <code>cargo new rust_app --bin</code>. It will create binary project structure
as below.</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sample_rust_app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Cargo.lock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Cargo.toml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── src</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    └── main.rs</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Content of Cargo.toml</p><div class="language-toml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-toml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[package]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = "rust_app"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">version = "0.1.0"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">edition = "2021"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A very simple <code>main.rs</code> which listens on a port and writes the content into the STDOUT stream.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::env;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::{BufRead, Error};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::net::{TcpListener, TcpStream};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() -&gt; std::io::Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let port = env::var("LISTEN_PORT").unwrap_or(String::from("8080"));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let listener = TcpListener::bind(format!("127.0.0.1:{}", port))?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // accept connections and process them serially</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for stream in listener.incoming() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    handle_client(stream?)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn handle_client(mut stream: TcpStream) -&gt; Result&lt;(), Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let mut reader = io::BufReader::new(&amp;mut stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let received: Vec&lt;u8&gt; = reader.fill_buf()?.to_vec();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  reader.consume(received.len());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  String::from_utf8(received)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          .map(|msg| println!("{}", msg))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          .map_err(|_| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            io::Error::new(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              io::ErrorKind::InvalidData,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              "Couldn't parse received string as utf8",</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="build">Build<a class="hash-link" href="#build" title="Direct link to heading">​</a></h3><p>Build the binary project using <code>cargo build --all-targets --workspace --release</code>. On successful build completion, binary
will be placed under <code>target/release/</code> directory. Let's try the binary with a sample input.</p><p>Run the binary while setting <code>LISTEN_PORT</code> to <code>9090</code> to accept messages on localhost 9090 TCP port.</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ </span><span class="token builtin class-name">export</span><span class="token plain"> </span><span class="token assign-left variable" style="color:#36acaa">LISTEN_PORT</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">9090</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ ./target/release/rust_app</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We are going to use netcat client to send message to TCP socket like below.</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ </span><span class="token builtin class-name">echo</span><span class="token plain"> sample_text </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">nc</span><span class="token plain"> localhost </span><span class="token number" style="color:#36acaa">9090</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now check the rust_app program terminal. It will show the same text i.e. <code>sample_text</code> which we sent through netcat
client.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="upload-archive-in-cloud-storage">Upload Archive in Cloud Storage<a class="hash-link" href="#upload-archive-in-cloud-storage" title="Direct link to heading">​</a></h3><p>Now we will concentrate how to build an installer for macOS. We choose Homebrew package manager. Homebrew requires a URL
to download your binary. There are a few choices to host your executable, like any cloud provider with file storage
service or may be GitHub Releases. For the current use case, I am using GitHub Releases because it is free and easy to
use.</p><p>From the rust source code example, the binary is archived (using <code>tar -C target/release -czf rust_app.tar.gz rust_app</code>)
and uploaded into a GitHub release and is available under
<a href="https://github.com/dasmanas/homebrew-rust-app/releases/download/v0.0.1/rust_app.tar.gz" target="_blank" rel="noopener noreferrer">https://github.com/dasmanas/homebrew-rust-app/releases/download/v0.0.1/rust_app.tar.gz</a> link. We will require this link
in the installation instruction.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="homebrew-to-create-the-macos-installer">Homebrew to Create the macOS Installer<a class="hash-link" href="#homebrew-to-create-the-macos-installer" title="Direct link to heading">​</a></h3><p>Homebrew offers a way to install formula from third party repositories (i.e. Taps) like GitHub repositories instead of
having it as part of core homebrew formula <a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="noopener noreferrer">homebrew-core</a>. We will create
one such GitHub project to host our formula. GitHub project name is <code>homebrew-rust-app</code> while following the naming
convention <code>homebrew-&lt;project_name&gt;</code> to have better convenience for the user while tapping the repository.</p><p>We will create the homebrew project in following structure which will hold the Ruby formula file under Formula directory
like shown here.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">homebrew-rust-app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Formula</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   └── listener.rb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── README.md</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The Ruby file contains the installation instruction of your binary. Here is a sample ruby file for the formula. Here we
will try to achieve a few things for our example.</p><ul><li>A macOS installer for the binary.</li><li>User of the software doesn't need manage any configuration. Defaults (config, env vars etc.) will be manage as part of
the installation.</li><li>Install the software under a managed directory by Homebrew. This gives more control to the software manufacturer to
support backward compatibility or cleaning up memory in at times specially during software version update.</li><li>An installer which can be run as background service.</li><li>Sample test case for the installer which can be performed even before starting the installer as background service
will provide a better determine if there is any potential issue.</li></ul><div class="language-ruby codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ruby codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Listener &lt; Formula</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  desc "A small description of your formula"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # A home page URL for your software</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  homepage "https://github.com/dasmanas/homebrew-rust-app/releases"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # URL from where the installer archive is available</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  url "https://github.com/dasmanas/homebrew-rust-app/releases/download/v0.0.1/rust_app.tar.gz"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # Sha256 can be calculated using "shasum -a 256 &lt;archive_name.tar.gz&gt;"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sha256 "c19c678e755d98506c372dd631640702ef2b7da225ffaee20453deb0c2b4a213"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  license "Apache-2.0"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  version "0.0.1"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def install</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ENV.deparallelize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Installing the app</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bin.install "rust_app"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def post_install</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Instruction to create a directory which may be used to manage file resources for the app. rust_app directory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # will be created under /usr/local/var directory.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (var/"rust_app").mkpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  # Section to add different instruction for the user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def caveats</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s = &lt;&lt;~EOS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      We've installed your rust_app.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      To test rust_app installation:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        brew test listener</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      To run rust_app Node as a background service:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        brew services start listener </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      To check the service status:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        brew services list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      To stop rust_app Node background service:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        brew services stop listener</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EOS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  service do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def envvarhash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return {PATH: std_service_path_env, LISTEN_PORT: "9090"}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    run [opt_bin/"rust_app"]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    keep_alive true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    process_type :background</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    environment_variables envvarhash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log_path var/"rust_app/logs/stdout/rust_app.log"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    error_log_path var/"rust_app/logs/stdout/rust_app.log"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    working_dir var/"rust_app"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  test do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (testpath/"rust_app").mkpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (testpath/"tmp").mkpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts testpath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    child_pid = fork do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "Child process initiated to run rust_app"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "Child pid: #{Process.pid}, pgid: #{Process.getpgrp}"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      #setsid() creates a new session if the calling process is not a process group leader.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Process.setsid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "Child new pgid: #{Process.getpgrp}"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "Initiating rust_app..."</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ENV.prepend "LISTEN_PORT", "9090"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      system "#{bin}/rust_app"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts "Waiting for rust_app TCP socket listener to be up..."</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sleep 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    begin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      system "echo sample_text | nc localhost 9090"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_match "rust_app",</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   shell_output("lsof -nP -i4TCP:9090 | grep LISTEN")</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rescue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "test1"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_raises(CustomError) do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        raise CustomError, 'This is really bad'</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ensure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pgid = Process.getpgid(child_pid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "Sending HUP to group #{pgid}..."</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Process.kill('HUP', -pgid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Process.detach(pgid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      puts "Parent process exiting..."</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the ruby script, the section <code>service do ... end</code> takes care of registering the software as background service. The
block of ruby script creates the required plist file under <code>~/Library/LaunchAgents/</code> for the Launch Agents. At the same
time it eliminates the need of handcrafted plist file. For more information you can always refer to Homebrew's
<a href="https://docs.brew.sh/Formula-Cookbook#service-files" target="_blank" rel="noopener noreferrer">Service files</a> official doc.</p><p>We also added a <code>test do ... end</code> section to the ruby script to demonstrate the test capability. User can run a test on
the installer even before starting the same as a service. </p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-install-your-software-as-service">How to install your software as service<a class="hash-link" href="#how-to-install-your-software-as-service" title="Direct link to heading">​</a></h3><p>Now it is ready to release the installer. To use the installer in macOS, here are some important tips.</p><ul><li>Tap the third party repository for the brew formula. E.g. <code>brew tap dasmanas/rust-app</code>.</li><li>Install the formula from the tap. E.g. <code>brew tap listener</code></li><li>Test the installed binary. E.g. <code>brew test listener</code></li><li>Install the binary as service. E.g. <code>brew services start listener</code>. Once service has started as background process,
the status of the service can be verified using <code>brew services list</code>.</li><li>Background service can be stopped at any time using brew's services utility. E.g. <code>brew services stop listener</code></li></ul><p>In Pyrsia we built similar kind of installer for macOS. If you are a macOS user, you may also like to take a
look at the code base from <a href="https://github.com/pyrsia/homebrew-pyrsia" target="_blank" rel="noopener noreferrer">homebrew-pyrsia</a> or try out
<a href="/docs/tutorials/quick-installation/">Quick Installation</a> guide to install Pyrsia. For any improvement suggestion or to
contribute open issue or pull request accordingly under <a href="https://github.com/pyrsia" target="_blank" rel="noopener noreferrer">Pyrsia</a> project.</p>]]></content:encoded>
            <category>rust</category>
            <category>macos</category>
            <category>installer</category>
            <category>homebrew</category>
            <category>brew</category>
        </item>
        <item>
            <title><![CDATA[Release 0.2.1]]></title>
            <link>https://pyrsia.io/blog/2022/11/30/pyrsia-0.2.1-released</link>
            <guid>/2022/11/30/pyrsia-0.2.1-released</guid>
            <pubDate>Wed, 30 Nov 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Announcing a new release]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="announcing-a-new-release">Announcing a new release<a class="hash-link" href="#announcing-a-new-release" title="Direct link to heading">​</a></h2><p>We are happy to announce the release of <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.1" target="_blank" rel="noopener noreferrer">version 0.2.1</a> today!</p><p>This release has incremental improvements over the <a href="https://github.com/pyrsia/pyrsia/releases/tag/v0.2.0" target="_blank" rel="noopener noreferrer">version 0.2.0</a> released at the CDSummit at Kubecon.</p><p>Other than usual software quality improvements this release includes the following:</p><ul><li>Better CLI experience - easy to configure</li><li>MacOSX installer is able to start the service automatically - better experience for getting started.</li><li>Automatically request builds on Pyrsia if an artifact does not exist on the network.</li><li>Improved and updated documentation</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="integration-tests-and-staging-environment">Integration tests and Staging environment<a class="hash-link" href="#integration-tests-and-staging-environment" title="Direct link to heading">​</a></h2><p>We invested a lot of time in this release to improve our testing etiquette.</p><p>We now have a set of <a href="https://github.com/pyrsia/pyrsia-integration-tests" target="_blank" rel="noopener noreferrer">integration tests</a> that we rely on to ensure that the network is stable and the functionality Pyrsia offers, continues to remain stable.</p><p>We did not have a dedicated infrastructure to test before going to production. As of this release we have a staging environment that allows us to test before we deploy to production.</p><p>More testing is better!</p><p>Please <a href="https://pyrsia.io/docs/tutorials/quick-installation/" target="_blank" rel="noopener noreferrer">download our installers</a>, try out Pyrsia with Docker and <a href="https://pyrsia.io/docs/community/get_involved/" target="_blank" rel="noopener noreferrer">let us know</a> if you are looking for something Pyrsia does not support yet.</p>]]></content:encoded>
            <category>pyrsia</category>
            <category>cli</category>
            <category>installer</category>
            <category>service</category>
            <category>configuration</category>
            <category>release</category>
            <category>0.2.1</category>
        </item>
        <item>
            <title><![CDATA[Why does Pyrsia use a Blockchain(and no CryptoCurrency)?]]></title>
            <link>https://pyrsia.io/blog/2022/10/10/why-does-pyrsia-use-a-blockchain</link>
            <guid>/2022/10/10/why-does-pyrsia-use-a-blockchain</guid>
            <pubDate>Mon, 10 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.]]></description>
            <content:encoded><![CDATA[<p>Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it is automatically associated with cryptocurrency and mining. But if you look closely, blockchain is simply an immutable ledger - immutable being the killer feature - which can be used in any situation where you need data to be tamper proof.</p><p>Blockchain technology is deployed to leverage the following features:</p><ul><li>Distributed ledger: Blockchain implementations use a distributed ledger and perform transactions based on consensus.</li><li>Consensus based commits: Typically blockchain implementations come with an implementation of a Byzantine Fault Tolerance (BFT) * algorithm<!-- -->[1]<!-- -->.</li><li>Transparency and Immutability: Blockchain transactions are transparent and immutable, meaning they cannot be tampered with, thus * increasing trust and confidence in the system.</li><li>Faster transactions: Third party verification is eliminated thus causing faster transactions.</li><li>Improved security: Blockchain transactions embed security within them which can be verified by third parties. Any attempts at adding malicious data make the blockchain invalid thus exposing breaches.</li></ul><p>A software supply chain backed by a consistent verifiable ledger using blockchain brings trust into the open source software world. Also as blockchain commits are typically implemented based on BFT they provide security against failures in a distributed network. This provides protection against malicious network nodes committing data to the blockchain.</p><p>In this blog we discuss how Pyrsia is a tool for securing your software supply chain. We discuss the application of blockchain technology to provide an immutable record of each open source software being built into a binary. We further discuss how other aspects of blockchain technology help us build a distributed system that can scale across the globe.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="software-supply-chain-security">Software Supply Chain Security<a class="hash-link" href="#software-supply-chain-security" title="Direct link to heading">​</a></h2><p>Software supply chain has received much attention since a few well known events have affected the software industry and these have also percolated into real lives of people (eg. Equifax data breach<!-- -->[2]<!-- -->, Solarwinds breach<!-- -->[3]<!-- -->, Log4Shell vulnerability<!-- -->[4]<!-- -->, Spring4Shell vulnerability<!-- -->[5]<!-- --> and many more).
Software supply chain has become a core topic of discussion within the software industry and also caused policy decisions<!-- -->[6]<!-- --> to solidify the security posture across the board.</p><p>The vulnerabilities discussed above and many more that go without receiving so much attention are discovered in the open source libraries that become part of the end user software. Much of this open source software development relies on few people’s effort and on tools that do not give insight into how the said software is being built. Establishing any level of trust becomes a challenge. Furthermore, once this open source software becomes part of the supply chain, we rely on a lot of manual effort to determine the components that are part of the software supply chain.</p><blockquote><p>Our proposal for Pyrsia <!-- -->[7]<!-- -->, a decentralized package network, aims to provide a solution for a key part of the supply chain.
Pyrsia aims to</p><ul><li>Build trust for the open-source packages being used as dependencies in software development through certified and peer-verified builds</li><li>Provide a decentralized package network that understands package coordinates, semantics, and discoverability, and which continues to work even though there are local outages</li></ul></blockquote><p>Pyrsia aims to provide a tool to establish and verify trust in the software delivery world. With Pyrsia we hope to provide a source of information that can be used to automate much of this effort. 75% software comes from open source components<!-- -->[8]<!-- --> and with Pyrsia as the mechanism to manage these components we look towards a future where software is liquid<!-- -->[9]<!-- -->.</p><p>Pyrsia aims to provide trustworthy provenance data which can be used to automate releases, patches and audit activities for the supply chain. Gathering all this information and sharing it with decentralized nodes requires a lightweight and tamperproof database.</p><p>In order to make Pyrsia’s goals successful we need to use a database that can serve the following requirements:</p><ul><li>Performant in a distributed setting</li><li>Tamperproof</li><li>Lightweight enough to be able to stream updates efficiently</li></ul><p>A blockchain implementation is a perfect fit since it provides all the above features and provides the ability to add verification mechanisms on top of it. Let’s talk a little bit more about the current state of the software supply chain.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="state-of-software-supply-chain">State of Software Supply chain<a class="hash-link" href="#state-of-software-supply-chain" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="lack-of-trustworthy-provenance-data">Lack of trustworthy provenance data<a class="hash-link" href="#lack-of-trustworthy-provenance-data" title="Direct link to heading">​</a></h3><p>As it stands today we implicitly rely and trust the central repositories to provide updates to open source libraries. But evidence has shown that such implicit trust is not sufficient to secure the supply chain. There have been instances that show how this trust can be breached either by a rogue agent taking over control from the rightful owner (email squatting, typosquatting 1, typosquatting 2) or even the rightful owner turning rogue for some reason or getting burnt out.</p><p>Overall building a definitive SBOM for your software continues to be a challenge. Querying to determine versions, related vulnerabilities, dependency chains and potential remediation still remains a manual process. Such manual processes are error prone and require investment of effort similar to that of building original software and thus do not get enough attention until disaster has struck.</p><p>Pyrsia started with a goal of building such a provenance log which is easy to use with automation, and scales across a distributed network.</p><p>Pyrsia aims to keep the nodes on the network up to date using a peer to peer update mechanism. This is critical so that many of the Pyrsia functions can be performed on the peer node without having to traverse. the network. The critical part here that needs to be upto date is the provenance log which is powered by the blockchain.</p><p>This provenance log will further support an automation infrastructure to aid software delivery decisions which currently requires manual intervention.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dependence-on-centralized-repositories">Dependence on centralized repositories<a class="hash-link" href="#dependence-on-centralized-repositories" title="Direct link to heading">​</a></h3><p>Realizing that centralized repositories have run their course in terms of being a source of trust and reliability, we started the Pyrsia design with emphasis on being distributed by design.
We need a distributed network since centralized repositories lack the reliability and scale that decentralized systems can provide.</p><p>Pyrsia relies on the peer-to-peer (P2P) communication mechanisms (think bittorrent) to exchange artifacts, metadata about those artifacts and also the provenance log. Pyrsia leverages two different channels to make these network transfers efficient. One channel delivers artifacts and another channel is used to synchronize the blockchain over the network. Artifacts are delivered on demand but the provenance log is updated frequently and this information needs to be lightweight - which is facilitated by the append-only blockchain. Leveraging the P2P technology makes Pyrsia resilient to internet failure modes (data center failures or network failures) and allows the network to scale organically - even across geographical boundaries where data center availability may be a challenge.</p><p>But using this technology also meant that Pyrsia could not rely on traditional data distribution mechanisms (like distributed databases, network caches, CDNs etc). Pyrsia needed a distributed database that was easy to update and transmit (read: serialize) over the network. Since P2P networks are also fault tolerant we needed to ensure that such a database can be usable from the local Pyrsia node (think git).</p><p>Given these constraints/requirements we started thinking about using a blockchain as a possible solution.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="trustworthy-means-tamperproof">Trustworthy means tamperproof<a class="hash-link" href="#trustworthy-means-tamperproof" title="Direct link to heading">​</a></h3><p>The main feature that Pyrsia provides is a reliable and verifiable log for asserting your dependencies. This means that we need a log that is append only, written once and read many times and its entries to be immutable. We need a database that is tamper proof with guarantees of discovering and resolving any malicious additions. Blockchain technology has proved to be one of those immutable databases.</p><p>Hence we chose a Blockchain technology that acts as an immutable ledger for the purpose of storing all data related to artifacts. Furthermore as we mentioned before  Blockchain implementation requires a consensus mechanism based on BFT to ensure that there is security against taking over the network. An implementation of Blockchain implements BFT to ensure there is consensus for each block of data committed. BFT algorithms are resilient against network attacks that span the network and can tolerate upto ⅓ of the network failures. For a reasonable sized network getting control of ⅓ of the network nodes is a costly operation for hackers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pyrsia-design">Pyrsia Design<a class="hash-link" href="#pyrsia-design" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="provenance-log">Provenance Log<a class="hash-link" href="#provenance-log" title="Direct link to heading">​</a></h3><p>Pyrsia is built to provide a Provenance log to provide enough information about open source software. This information can be used to build decision making automation to enable releases and control what can be released. This provenance log is built to be lightweight so that a large number of software binaries can be tracked efficiently. In order to store such a provenance log we need a storage solution that has auditable and verifiable links that connect to history. Blockchain or immutable ledgers provide an efficient mechanism to store such chains of information and allow for quick retrieval.</p><p>Another feature Pyrsia is building is a search engine that can provide provenance log for each version, each binary type and each binary name. Pyrsia needs to parse this information quickly so that search indexes remain current at all times..Compared to the heavy footprint of the artifacts themselves the blockchain is much more lightweight and intends to keep itself that way. As the ecosystem grows this database will grow in size but still remain magnitudes smaller than the artifact storage.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="network-structure">Network Structure<a class="hash-link" href="#network-structure" title="Direct link to heading">​</a></h3><p>Pyrsia’s design contains a network structure that provides direct connectivity between peers thus allowing for immense scale. Having said that, given the emphasis on security we have a differentiation between nodes that run in the cloud and the ones that are run on individual/volunteer nodes. The nodes that run on the cloud have the ability to act as a large cache, have better network throughput thus providing a bigger conduit to reach the repositories. The volunteer nodes provide a P2P network, a sort of proxy cache to content and an effective distribution mechanism. The authority nodes are the only ones that can commit to the ledger and thus provide a trustworthy provenance log.</p><p><img loading="lazy" alt="Pyrsia Network Design" src="/assets/images/provenance_log_architecture-35063e6d133a93eff6748500a10ad689.png" title="Pyrsia Network" width="1838" height="1766" class="img_ev3q"></p><p>Along with this the nodes on the cloud are deployed and maintained by Pyrsia governing organizations (Governing organizations are listed on <a href="https://pyrsia.io/" target="_blank" rel="noopener noreferrer">https://pyrsia.io/</a>). Having these owned by organizations instead of individuals enhances the availability of these nodes as well as vastly improves the security posture. We are now able to verify these nodes, provide identity mechanisms to have a provable chain of authority and provide membership privileges to keep the network secure - while scaling it across regions.</p><p>This network structure allows us another luxury, that of ensuring we control the data that is being committed to the blockchain. Early on we decided that Pyrsia will only allow the cloud nodes to commit to the blockchain using a consensus mechanism. This consensus mechanism will only allow authorized cloud nodes to commit and thus reduce the complexity of the consensus mechanism. Another aspect we realized is that, given Pyrsia will have very limited participants being able to commit to the blockchain we can stay away from the expensive, mining heavy, at times quite wasteful algorithms. Thus we steered clear from investing into the Proof of Work, Proof of Stake and similar algorithms. We have been focusing on using the Proof of Authority which has significantly reduced the complexity while providing us with sufficient control to keep the network secure.</p><p>In this design the authority is assigned and cannot be obtained through the means that are used on the open networks. Pyrsia governance organizations approve every node that has the authority to commit to the blockchain. This furthers our goal of providing a trustworthy network which has more control over what is available on the network. The Authority nodes are the only ones committing to the blockchain and then transmitting those updates to the peer nodes.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="leveraging-the-blockchain-technology">Leveraging the Blockchain technology<a class="hash-link" href="#leveraging-the-blockchain-technology" title="Direct link to heading">​</a></h2><p>Given the above criteria and constraints and evidence of success of the blockchain technology we found that the right fit for Pyrsia’s provenance log - which is its source of truth - using an implementation of blockchain technology was the right choice for Pyrsia.</p><p>We further assessed available implementations of blockchain and narrowed our choice of implementation based on the following criteria:
Availability of multiple language support - especially good documentation for a Rust implementation
Ability to turn of or not have the concept of Currency to make transactions on the network
Ability to choose the consensus algorithms that fit Pyrsia’s need and situation - Proof of Authority</p><p>We found that AlephBFT supported all these criteria and was easy to get started. We have been able to also build on top of AlephBFT to constrain the use cases of Pyrsia without giving away security. AlephBFT has also allowed us to configure the network nodes in a way that allows us the control we need to support the security.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="blockchain-does-not-mean-crypto">Blockchain does not mean Crypto<a class="hash-link" href="#blockchain-does-not-mean-crypto" title="Direct link to heading">​</a></h2><p>One thing we have learnt over the course of this effort is that - whenever we talk about blockchain as the technology we use in Pyrsia, we have received critical feedback about how we are overcomplicating our design. When we reflected on this feedback we realized that the majority of it is due to the prevalent use of blockchain within the cryptocurrency world.</p><p>Blockchain became popular by being widely adopted in the cryptocurrency implementations as the default mechanism to facilitate and verify transactions. The connection is so strong that when the term blockchain is used - it automatically gets associated with cryptocurrency and mining. And we have found that it is really hard to break this association. We also found that the most popular implementations connect the mining and crypto aspects to the blockchain in such a way that they become inseparable.</p><p>Blockchain will act as the immutable ledger giving us the tamper proof database we need, with the ability to search it efficiently and distribute it across the peers as we need.</p><p>Pyrsia is open source and free. The key to ensuring that the open source community continues to engage and use Pyrsia is that there should not be any currency attached with actions on Pyrsia. From the get go this has been our main objective to keep this network free and open to use for the community and we have worked to implement an immutable ledger which does not have the concept of cryptocurrency in it. Our implementation has removed the requirement of requiring gas (a fuel to power your transactions on the blockchain) or currency for participation. Given the security concerns Pyrsia operates on a small number of Pyrsia nodes that participate in consensus. Running the Proof of Authority algorithm from certified nodes and limiting those number of nodes to the participants of the governing board, allows Pyrsia to maintain security without being open to any mining on the network. Pyrsia will also benefit from the lightweight implementation of AlephBFT so that we can scale across regions and keep the network always up to date.</p><p>Pyrsia aims to leverage blockchain to power the provenance data while not allowing any usage of cryptocurrency on the network. We believe that open source should be free to use and should not have incentives attached to it to allow for fairness. Pyrsia builds on the success of blockchain while saving resources (energy) by not allowing any competitive currency exchange on the network.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="in-summary">In Summary<a class="hash-link" href="#in-summary" title="Direct link to heading">​</a></h2><p>Pyrsia leverages blockchain as an immutable ledger to provide a scalable provenance log. Blockchain technology is best suited for distributed large amounts of chained data across wide networks which is evidenced from the success of blockchain in the cryptocurrencies. Pyrsia is using this same technology to improve the state of the software supply chain by providing transparency into how open source software is being built on this network. This transparency is aimed to give you the confidence to use the open source library in your production environments.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h3><ul><li><a href="https://decrypt.co/resources/byzantine-fault-tolerance-what-is-it-explained" target="_blank" rel="noopener noreferrer">Byzantine Fault Tolerance</a></li><li><a href="https://www.synopsys.com/blogs/software-security/equifax-apache-struts-vulnerability-cve-2017-5638/" target="_blank" rel="noopener noreferrer">Equifax data breach</a></li><li><a href="https://www.businessinsider.in/tech/news/heres-a-simple-explanation-of-how-the-massive-solarwinds-hack-happened-and-why-its-such-a-big-deal/articleshow/79945993.cms" target="_blank" rel="noopener noreferrer">Solarwinds breach</a></li><li><a href="https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/" target="_blank" rel="noopener noreferrer">Log4Shell vulnerability</a></li><li><a href="https://jfrog.com/blog/springshell-zero-day-vulnerability-all-you-need-to-know/" target="_blank" rel="noopener noreferrer">Spring4Shell vulnerability</a></li><li><a href="https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/" target="_blank" rel="noopener noreferrer">Executive order on improving nations cybersecurity</a></li><li><a href="https://pyrsia.io" target="_blank" rel="noopener noreferrer">Pyrsia Proposal</a></li><li><a href="https://www.synopsys.com/software-integrity/resources/analyst-reports/open-source-security-risk-analysis.html?intcmp=sig-blog-rsa22" target="_blank" rel="noopener noreferrer">75% software comes from open source components</a></li><li><a href="https://jfrog.com/whitepaper/a-vision-of-liquid-software/" target="_blank" rel="noopener noreferrer">Software is Liquid</a></li></ul>]]></content:encoded>
            <category>blockchain</category>
            <category>consensus</category>
            <category>cryptocurrency</category>
            <category>proof-of-work</category>
            <category>proof-of-stake</category>
            <category>security</category>
            <category>transparency</category>
            <category>provenance</category>
        </item>
        <item>
            <title><![CDATA[Why Pyrsia is being built in Rust?]]></title>
            <link>https://pyrsia.io/blog/2022/09/30/why-pyrsia-is-being-built-in-rust</link>
            <guid>/2022/09/30/why-pyrsia-is-being-built-in-rust</guid>
            <pubDate>Fri, 30 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.]]></description>
            <content:encoded><![CDATA[<p>When we started working on Pyrsia we had the difficult and exciting task of choosing a language that would work for building secure supply chain software. We will share some details of how we decided to build Pyrsia in Rust and how it fits the problem we are set to solve.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="securing-open-source-software">Securing Open Source Software<a class="hash-link" href="#securing-open-source-software" title="Direct link to heading">​</a></h2><p>Open source software is built mostly by people passionate about solving a problem and sharing their solutions widely. One of the differences in how we build proprietary software vs open source is that we find that many of those original developers do their best in keeping the software upto date and try to patch vulnerabilities as soon as they can. Although their efforts are usually the best they can do. In some well publicized cases, developers have experienced burnout and lack of interest in supporting what they built, due to resource constraints.</p><p>For proprietary software, there are well published processes and patterns which are used to build software and record how it was done. Open Source software usually does not get this rigor and often is found vulnerable.</p><p>On Pyrsia we focus on this missing piece of building open source software and are building a platform that offers build from source service while providing a record of how it was done. Pyrsia leverages a peer-to-peer distribution model for these binaries thus making the network resilient to failures.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="secure-software-needs-a-secure-platform">Secure Software needs a secure platform<a class="hash-link" href="#secure-software-needs-a-secure-platform" title="Direct link to heading">​</a></h3><p>While the aim of Pyrsia is to secure the software that it builds, a lot of trust/community involvement expects the network itself to be secure. Pyrsia as a platform has taken this expectation seriously and from the initial days invested a lot of energy into building it right.</p><p>A few other considerations that were made during the initial discussions of Pyrsia include:</p><ul><li>Decentralized network (think Web3) to leverage distribution of binaries across regions</li><li>Build from source using independent randomly chosen nodes to ensure security by reducing surface of attack</li><li>Consensus mechanism to ensure that multiple nodes participate in the build and verification process</li><li>Deploying Pyrsia node instances on wide variety of architectures, operating systems, as well as footprints(think Intel Xeon all the way to Raspberry * Pi and beyond)</li><li>Ensuring wide deployments have a minimal footprint - for transportation, but more importantly to further reduce the possibility of attacks</li><li>Modern software that allows system programming - to enhance experience and also to restrict how the data structures can be used. Constraining how the software is built is key to making it more secure.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="choosing-a-programming-language">Choosing a programming language<a class="hash-link" href="#choosing-a-programming-language" title="Direct link to heading">​</a></h2><p>For Pyrsia to address the above considerations we weighed them against a few popular languages with decent community voice and size.</p><p>Specifically we were looking for the following in a programming language ecosystem:</p><ul><li>Welcoming community - People come first</li><li>Modern language constructs that help us focus on the problem instead of the language</li><li>Secure or easily to build for security</li><li>Multiple OS and Arch support</li><li>Ability to drop down to lower level to help implement any cryptography, improve performance</li><li>Support for web3 implementations like p2p networking, blockchain, cryptography</li><li>Installed base of system software in the language</li></ul><p><a href="http://rustlang.org" target="_blank" rel="noopener noreferrer">Rust</a> seemed to satisfy all these requirements, in fact with flying colors.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="rust-language">RUST Language<a class="hash-link" href="#rust-language" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rust-philosophy-1">Rust philosophy <!-- -->[1]<a class="hash-link" href="#rust-philosophy-1" title="Direct link to heading">​</a></h3><blockquote><p>Today we are very proud to announce the 1.0 release of Rust, a new programming language aiming to make it easier to build reliable, efficient systems. Rust combines low-level control over performance with high-level convenience and safety guarantees. Better yet, it achieves these goals without requiring a garbage collector or runtime, making it possible to use Rust libraries as a "drop-in replacement" for C.</p></blockquote><p>What makes Rust different from other languages is its type system, which represents a refinement and codification of "best practices" that have been hammered out by generations of C and C++ programmers. As such, Rust has something to offer for both experienced systems programmers and newcomers alike: experienced programmers will find they save time they would have spent debugging, whereas newcomers can write low-level code without worrying about minor mistakes leading to mysterious crashes.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="history-of-rust-2">History of Rust <!-- -->[2]<a class="hash-link" href="#history-of-rust-2" title="Direct link to heading">​</a></h3><blockquote><p>Rust began as a side project of Graydon Hoare, an employee at Mozilla. In short order, Mozilla saw the potential of the new language and began sponsoring it, before revealing it to the world in 2010.
One possible source of the name, according to Hoare, is the rust fungus. This has caused Rust programmers to adopt “Rustaceans” as their moniker of choice.</p><p>Despite its relative youth, Rust has steadily risen in the ranks of popular programming languages. In fact, while it ranked 33 in July 2019, by July 2020 it had risen to the 18th spot on the <a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener noreferrer">TIOBE Programming Community Index</a>. Similarly, according to <a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener noreferrer">Stack Overflow Developer Survey</a>, Rust has been the <code>most loved</code> language since 2016.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="rust-language-ecosystem">Rust language ecosystem<a class="hash-link" href="#rust-language-ecosystem" title="Direct link to heading">​</a></h3><p>The above philosophy made Rust a great candidate for use in security solutions like Pyrsia. Some other aspects that sealed the deal as a programming language for us were:</p><ul><li>Performance close to equivalent C level programs <!-- -->[3]</li><li>Concurrent programming without the garbage collection <!-- -->[4]</li><li>Rust has a borrow checker which ensures references do not outlive the data</li><li>Rust can be compiled to reduced instruction set architectures</li></ul><p>Along with the above, we also found that the initial set of libraries(libp2p, AlephBFT) we were looking to support, had mature implementations in rust. Also we found that the communities that supported these libraries were welcoming all implementers and learners alike. This openness within the Rust community in general made the choice easier for us.
A lot of these appealing features of the Rust ecosystem are well summarized in <!-- -->[5]<!-- -->.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="summary">Summary<a class="hash-link" href="#summary" title="Direct link to heading">​</a></h2><p>When we set out to change how open source software is secured we had a choice to make - the language to build the security solution with. When we surveyed what was available there were multiple options. C due to its performance, Golang because of its mature installations in the wild, Rust as an up and coming community with performance and modern language features.</p><p>In the end it was clear to us that Rust was the right choice to make and we have started building Pyrsia in Rust. We realize that we have a steep learning curve and we are learning as a group. Come join us on our <a href="https://cdeliveryfdn.slack.com/join/shared_invite/zt-1eryue9cw-9YpgrfIfsTcDS~hGHchURg" target="_blank" rel="noopener noreferrer">Slack channel</a> to discuss more.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h3><ul><li><a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html" target="_blank" rel="noopener noreferrer">Rust Philosophy</a></li><li><a href="https://www.talentopia.com/news/the-rust-programming-language-its-history-and-why/" target="_blank" rel="noopener noreferrer">Rust History</a></li><li><a href="https://codilime.com/blog/rust-vs-c-safety-and-performance-in-low-level-network-programming/" target="_blank" rel="noopener noreferrer">Rust vs C</a></li><li><a href="https://discord.com/blog/why-discord-is-switching-from-go-to-rust" target="_blank" rel="noopener noreferrer">Garbage collection issues</a></li><li><a href="https://codilime.com/blog/why-is-rust-programming-language-so-popular/#:~:text=High%20performance%20and%20safety%20are,amounts%20of%20data%20very%20quickly" target="_blank" rel="noopener noreferrer">Why projects use Rust?</a></li></ul>]]></content:encoded>
            <category>rustlang</category>
            <category>rust</category>
            <category>security</category>
            <category>web3</category>
            <category>modern</category>
            <category>safety</category>
            <category>community</category>
            <category>ecosystem</category>
        </item>
        <item>
            <title><![CDATA[Peer Metrics in the Pyrsia Network]]></title>
            <link>https://pyrsia.io/blog/2022/06/03/peer-metrics</link>
            <guid>/2022/06/03/peer-metrics</guid>
            <pubDate>Fri, 03 Jun 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and "fast". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.]]></description>
            <content:encoded><![CDATA[<p>Since the advent of peer-to-peer networks in the 1970s, we have seen them applied in a variety of use cases on the internet. From the first usages in the Usenet network, to the infamous Napster network, astute developers have created peer networks to enable sharing of information and data without the use of central servers. Over the past few years, we have seen a new increase in the use of peer to peer networks and formalization of algorithms to implement these networks. The Pyrsia network is an example of a new application of peer to peer networks. Pyrsia is an open-source project that is designed to build trust that an open-source distribution is free of malicious code via a consensus algorithm, then share that distribution amongst the peers. An important goal of this project is to create a peer network that is reliable and "fast". To do this, the team added a unique feature to the peer network protocol that helps one peer in the network choose the best peer to download software distributions.</p><p>Herein I present the mechanism the Pyrsia team has created to help improve the selection process for downloading software distributions from peers. The idea is to improve upon the Kademila peer selection process and make "smarter" choices from Pyrsia peers based on a "peer metric". The mechanism is layered atop the Kademila peer selection process, which in Pyrisa returns a list of peers known to be in possession of an open-source distribution of interest. The peer metric is a real time assessment of the work-load of any given machine in the network, both related and unrelated to any current software transfers within the Pyrsia network.</p><p>The following table defines terms used in this blog.</p><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Requester</td><td>In this context a requestor is a Pyrsia client requesting a file to be downloaded or uploaded to/from its peer(s).</td></tr><tr><td>Peer (Pyrsia Peer)</td><td>Any Pyrsia client that is participating in the network.</td></tr><tr><td>Neighboring Node</td><td>Any node that is returned by the Kademila algorithm as having a software distribution desired by a peer.</td></tr></tbody></table><p>As previously stated, a primary goal of the peer-to-peer software distribution sharing function of Pyrsia is that it efficiently uses peers. The efficient use of peers can be broken down into two aspects, efficiencies related to uploading software distributions to peers and efficiencies related to downloading software distributions from peers. This post limits the discussion to downloading software distributions from peers.</p><p>The primary rule defined by our selection process is that requesters must not overwhelm peers by requesting too many software distributions too often from any one neighboring node. Though hard resource usage limits are a configuration function for Pyrsia Peers, Pyrsia’s peer selection mechanism should also attempt to balance requests across the network of peers. Additionally, the peer selection mechanism should operate such that file requesters are not starved for bandwidth in the network by unresponsive peers, preventing fast downloads. While the first efficiency could be guaranteed by Pyrsia policy, the second one is more nebulous because Pyrsia cannot guarantee enough stable network peers exist at request times to achieve “fast downloads”.</p><p>The terms “fast downloads” and “requesting too much data” must be further defined to quantify what is meant. The means of describing these terms can be defined as a function of the attributes within the environment. There are measurable attributes of both the network and the Pyrsia peers participating in the networks that can help us define metrics to balance requests. These metrics will ultimately determine the quality of peers in the requesters' peer list. The term quality in this context is related to the ability of a peer to satisfy a request for download and will be defined by the function Q(x):</p><p><img loading="lazy" src="https://latex.codecogs.com/svg.image?Q(x)&amp;space;=&amp;space;%5Csum_%7Bn=1%7D&amp;space;%5E%7Bpa%5C&amp;space;count%7D&amp;space;pa_n&amp;space;*&amp;space;weight" alt="$Q(x) = \sum_{n=1} ^{pa\ count} pa_n * weight" class="img_ev3q"></p><p>where <code>pa</code> is a peer attribute of the environment and <code>weight</code> is a number that determines the expense of the attribute. The quality number will be calculated on demand by peers returned in the list of peers generated by the Kadimela algorithm. The quality function can be used for either upload quality or download quality depending on the need. The metric is currently used during the selection process for downloading software distributions. Finally, we need to define what characteristics are important to drive analytics for decisions about transactions on the network. The following table lists the attribute used by to Pyrsia generate the peer metric in Pyrsia. The peer with the lowest number is considered to be the ideal candidate for the software distribution download.</p><table><thead><tr><th>Peer Attribute</th><th>Definition</th></tr></thead><tbody><tr><td>Peer Network Load</td><td>A measurement of the current network bandwidth usage in terms packets in and packet out summed over all network interfaces.</td></tr><tr><td>CPU Load</td><td>The average CPU load over the last minute</td></tr><tr><td>Disk I/O Load</td><td>A measure of the current packets being read and written summed over all current processes on the system</td></tr></tbody></table><p>This system of measuring the quality of peers will evolved over time and as other attributes are defined, they will be integrated into the Pyrsia network.</p>]]></content:encoded>
            <category>p2p</category>
            <category>peer-metrics</category>
        </item>
        <item>
            <title><![CDATA[Blockchain Consensus]]></title>
            <link>https://pyrsia.io/blog/2022/01/28/blockchain-consensus</link>
            <guid>/2022/01/28/blockchain-consensus</guid>
            <pubDate>Fri, 28 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Blockchain technologies are trending. There’s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.]]></description>
            <content:encoded><![CDATA[<p>Blockchain technologies are trending. There’s a lot of information about what they do and how they work but often these are abstract high level overviews. Looking beneath the surface, these overviews skip some of the most fascinating parts of the implementations that bring these technologies to life.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-is-a-blockchain">What is a Blockchain<a class="hash-link" href="#what-is-a-blockchain" title="Direct link to heading">​</a></h2><p>IBM has one of my <a href="https://www.ibm.com/topics/what-is-blockchain" target="_blank" rel="noopener noreferrer">favorite definitions</a>:</p><blockquote><p>&nbsp;Blockchain is a shared, immutable ledger that facilitates the process of recording transactions and tracking assets <!-- -->[<!-- -->... on] a network.
An asset can be tangible (a house, car, cash, land) or intangible (intellectual property, patents, copyrights, branding). Virtually
anything of value can be tracked <!-- -->[<!-- -->... ] on a blockchain network, reducing risk <!-- -->[<!-- -->...] for all involved.</p></blockquote><p>There’s a few key items to highlight from this definition are:</p><ul><li>A shared, immutable ledger</li><li>Recording and tracking assets</li></ul><p>Simply put, a Blockchain is a list of changes to assets, called transactions, which are grouped in blocks that are recognized by all participants in the network.</p><p>Unfortunately, it leaves out one major element. How do blockchain networks reduce risk? How do blockchain networks agree on the shared ledger?</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="consensus">Consensus<a class="hash-link" href="#consensus" title="Direct link to heading">​</a></h2><p>In the world of blockchain, consensus is the agreement of which block is next. Collectively all the participants in the blockchain’s network
should come to the same conclusion.</p><p>You’ve probably heard of “Proof of Work”, usually called mining, and “Proof of Stake”, these two are the most popular in terms of market share
in the crypto markets.</p><p>These consensus algorithms were some of the first to be popularized by projects like Bitcoin and Ethereum. These are far from the only ones, Proof of Authority, Proof of Burn, Proof of Capacity and Proof of History are just from others mentioned on <a href="https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp" target="_blank" rel="noopener noreferrer">Investopedia's Website</a>.</p><p>Let’s dive deeper into the two popular algorithms to see how they obtain consensus.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="proof-of-work">Proof of Work<a class="hash-link" href="#proof-of-work" title="Direct link to heading">​</a></h3><p>Proof of Work is based on a mathematical expression which is very costly to compute a magic number, called a nonce, but easily verified. Each participant, typically referred to as a miner, begins the calculation with the transitions it’s heard on the network since the last published block. Participants race each other to find the right answer and the winner traditionally gets a reward. It’s difficult to cheat and very rewarding to operate in good faith.</p><p>At the time of writing, January 28th 2022, the reward is 6.25 BTC which is worth 236,755 USD. It’s easy to draw parallels to the 1849 Gold Rush.</p><p><img loading="lazy" src="https://lh4.googleusercontent.com/lbGxZlJRF5GlNLNmbQlnS7Rdk0CHU9w2QjyfghfFLKWOa-bz7ZaEq83AWwVwEd4oJXZgUhyBQxzZ_-_6ytuISeQXU1er77nfwYpdoPgaE_8bvQqKFdsLmUVRbuc9NrePRDTtcZ7YbkqgTq5RMg" alt="BitCoin Value" class="img_ev3q"></p><p>When miners hear of a new block, they immediately stop their calculation and begin listening for more transactions. This is approximately a 10 minute window for Bitcoin.</p><p>With a small number of competitors it’s pretty straightforward but when tens of thousands of nodes are involved, what happens if two miners finish at the same time. Who wins?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="proof-of-stake">Proof of Stake<a class="hash-link" href="#proof-of-stake" title="Direct link to heading">​</a></h3><p>Proof of Stake is an investment strategy where committing more capital means you’re more likely to get the reward. <a href="https://www.peercoin.net/whitepapers/peercoin-paper.pdf" target="_blank" rel="noopener noreferrer">Peercoin</a>, a very early PoS implementation, kept the mining of PoW but required less computational complexity the more <em>coinage</em> was staked. If two participants offer the same investment in the next block, which one is rewarded?</p><p>If someone is able to offer more capital for their block to be accepted, are they able to always win? Yes, this is a special type of security exploit called a 51% attack. If the confirmation of the next block is tied to a resource, then an entity which holds a majority stake can take control of the blockchain. Proof of Work is also susceptible to this type of attack.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="stale-and-orphan-blocks">Stale and Orphan Blocks<a class="hash-link" href="#stale-and-orphan-blocks" title="Direct link to heading">​</a></h3><p>Most blockchain’s are actually trees, not linked lists which is what probably comes to mind for young data scientists. This probably comes as a shock but it’s the secret ingredient to solving our racing condition when two participants propose the next block in PoW.</p><blockquote><p>If two nodes broadcast different versions of the next block simultaneously, some
nodes may receive one or the other first. In that case, they work on the first one they received,
but save the other branch in case it becomes longer.
The tie will be broken when the next proof-of-work is found and one branch becomes longer.</p></blockquote><p><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener noreferrer"><em>Bitcoin: A Peer-to-Peer Electronic Cash System Section 5</em></a></p><p>Chains are made of links that connect to others. This data structure is referred to as a linked list, when a link
points to both it’s parent and child is a doubly linked list. Three sequential blocks being published would make the following chain:</p><div class="mermaid" data-mermaid-src="stateDiagram-v2
    [*] --> Block_1
    Block_1 --> Block_2 : Parent
    Block_2 --> Block_3 : Child
    Block_3 --> [*]">stateDiagram-v2
    [*] --&gt; Block_1
    Block_1 --&gt; Block_2 : Parent
    Block_2 --&gt; Block_3 : Child
    Block_3 --&gt; [*]</div><p>If block 4 was published at the same time as our block 3 a node would have the following tree:</p><div class="mermaid" data-mermaid-src="stateDiagram-v2
    [*] --> Block_1
    Block_1 --> Block_2 : Parent
    Block_2 --> Block_3 : Child
    state Block_2 <<fork>>
        Block_2 --> Block_4 : Nephew
        Block_3 --> Block_5
    Block_5 --> [*]">stateDiagram-v2
    [*] --&gt; Block_1
    Block_1 --&gt; Block_2 : Parent
    Block_2 --&gt; Block_3 : Child
    state Block_2 &lt;&lt;fork&gt;&gt;
        Block_2 --&gt; Block_4 : Nephew
        Block_3 --&gt; Block_5
    Block_5 --&gt; [*]</div><p>Since it’s extremely unlikely that a second pair of blocks would also be published at the same time, the tie is broken when the next sequential block is published. This is block 5 in the diagram above.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="which-branch-should-we-follow">Which branch should we follow<a class="hash-link" href="#which-branch-should-we-follow" title="Direct link to heading">​</a></h4><p>Well, intuitively the “strongest” branch of our tree is the one we should stick with. The strength comes from the amount of work that has gone into making the branch. More work means it’s less likely that someone has cheated or lied.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic-validator-sets">Dynamic Validator Sets<a class="hash-link" href="#dynamic-validator-sets" title="Direct link to heading">​</a></h3><p><a href="https://ethereum.org/en/upgrades/merge" target="_blank" rel="noopener noreferrer">Ethereum’s new PoS system named <em>Consensus Layer</em></a>, <a href="https://blog.ethereum.org/2022/01/24/the-great-eth2-renaming/" target="_blank" rel="noopener noreferrer">formally Ethereum 2.0</a>, is still in development but it’s leading implementation is <a href="https://arxiv.org/pdf/1710.09437.pdf" target="_blank" rel="noopener noreferrer">Casper FFG</a>&nbsp;<a href="https://eips.ethereum.org/EIPS/eip-1011" target="_blank" rel="noopener noreferrer"><sup>[<!-- -->2<!-- -->]</sup></a> (there’s also <a href="https://vitalik.ca/general/2018/12/05/cbc_casper.html" target="_blank" rel="noopener noreferrer">this</a> alternative) which uses a Byzantine Fault Tolerance consensus.</p><p>In Proof of Stake, the participants are called validators who’s role is similar to miners in Proof of Work. The validator is staking money on the block that it thinks should be added to the chain. If the block gets appended, then they get a reward that is proportional to the bet that they placed on the block. <a href="https://www.chubbydeveloper.com/ethereum-proof-of-stake-casper-ffg-vs-casper-cbc/" target="_blank" rel="noopener noreferrer"><sup>[<!-- -->1<!-- -->]</sup></a><sup> </sup>Validators are responsible for following the forking rules when staking checkpoints. Validators decide which block is the best by following a set of rules.</p><p><a href="https://arxiv.org/pdf/1710.09437.pdf" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/1710.09437.pdf</a></p><p>The proposal set the stake deposit at 32 ETH to be eligible to act as a validator. At the time of writing that has a value of 81,374.81 USD even after a recent drop in value.</p><p><img loading="lazy" src="https://lh6.googleusercontent.com/yqYvnvnQNbf46dzgQQcndXR8eFjm_LYe-6ND4GslxLlyxtZamkv5q6deQjMVayYz9cHNvzh8UbOwcl4Q897KJEJp_mtCHi0x3WvMWN8b9cG-1zDiLnuQ-lQiBaC2H6D66O-8x2umwhzTkWLbJA" alt="ETH Value" class="img_ev3q"></p><p>There’s a few key concepts employed in Casper FFG, many are outlined in the <a href="https://eips.ethereum.org/EIPS/eip-1011#glossary" target="_blank" rel="noopener noreferrer">EIPS 1011’s Glossary</a></p><ul><li>Checkpoint is the block in the finalization stage</li><li>Epoch is the range of blocks between checkpoints. This grow by one block for each new epoch</li><li>Dynasty refers to the number of finalized checkpoints in the chain. (Note: checkpoints do not reach finality unless a super-majority of votes are obtained in favor)</li></ul><p>The validators are <em>randomly</em> selected (this is not detailed in the proposals but details are available <a href="https://github.com/ethereum/casper/blob/4adeffce5709fcf2d36f4bc6ac27bbd62747d032/VALIDATOR_GUIDE.md" target="_blank" rel="noopener noreferrer">here</a>) based on who has deposited the correct funds. Participants must deposit the correct sum 2 dynasties in advance to join a validator set. In order to leave they must send a withdrawal request 2 dynasties in advance, however the funds are not returned for approximately 4 months since the withdrawal was requested.</p><p>Consensus, or finality, is not reached unless ⅔, a super-majority of votes have been gathered stating the checkpoint meets the forking rules “follow the chain containing the justified <!-- -->[<!-- -->block] of the greatest height”.</p><p>When a checkpoint is finalized all the blocks in it’s epoch are implicitly finalized as well. This also marks the start of a new dynasty, casting the previous on to history it can no longer be modified and reaches immutability. This is also when validators can enter or exit the staking on checkpoints.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><p><a href="https://developer.bitcoin.org/devguide/p2p_network.html?highlight=stale%20orphan#orphan-blocks" target="_blank" rel="noopener noreferrer">https://developer.bitcoin.org/devguide/p2p_network.html?highlight=stale%20orphan#orphan-blocks</a></p><p><a href="https://developer.bitcoin.org/devguide/block_chain.html?highlight=stale#block-height-and-forking" target="_blank" rel="noopener noreferrer">https://developer.bitcoin.org/devguide/block_chain.html?highlight=stale#block-height-and-forking</a></p><p><a href="https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/" target="_blank" rel="noopener noreferrer">https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/</a></p><p><a href="https://vitalik.ca/general/2017/12/31/pos_faq.html" target="_blank" rel="noopener noreferrer">https://vitalik.ca/general/2017/12/31/pos_faq.html</a></p><p><a href="https://medium.com/unitychain/intro-to-casper-ffg-9ed944d98b2d" target="_blank" rel="noopener noreferrer">https://medium.com/unitychain/intro-to-casper-ffg-9ed944d98b2d</a></p><p><a href="https://medium.com/@ppio/consensus-byzantine-fault-tolerance-402258ec7a60" target="_blank" rel="noopener noreferrer">https://medium.com/@ppio/consensus-byzantine-fault-tolerance-402258ec7a60</a></p><p><a href="https://ethresear.ch/t/casper-ffg-with-one-message-type-and-simpler-fork-choice-rule/103/31" target="_blank" rel="noopener noreferrer">https://ethresear.ch/t/casper-ffg-with-one-message-type-and-simpler-fork-choice-rule/103/31</a></p>]]></content:encoded>
            <category>blockchain</category>
            <category>consensus</category>
            <category>bitcoin</category>
            <category>ethereum</category>
            <category>proof-of-work</category>
            <category>proof-of-stake</category>
        </item>
    </channel>
</rss>